(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[548], { 6987: function (e, t, a) { Promise.resolve().then(a.bind(a, 8507)) }, 8507: function (e, t, a) { "use strict"; let n; a.r(t), a.d(t, { default: function () { return at } }); var l, r, i = a(3827), s = a(8603); a(2448); var o = a(7907), c = a(4090), d = a(9697), u = a(1918), p = a(3167), m = a(4210); let h = e => { switch (e) { case s.X0.Connected: return "Connected"; case s.X0.Connecting: return "Connecting..."; case s.X0.Disconnected: return "Disconnected"; default: return "Connecting..." } }, x = (e, t) => { let { view: a, state: { selection: { from: n } } } = e, l = document.querySelectorAll(".has-focus"), r = l.length, i = l[r - 1]; if (i && i.getAttribute("data-type") && i.getAttribute("data-type") === t || i && i.classList && i.classList.contains(t)) return i; let s = a.domAtPos(n).node, o = s; for (o.tagName || (o = s.parentElement); o && !(o.getAttribute("data-type") && o.getAttribute("data-type") === t) && !o.classList.contains(t);)o = o.parentElement; return o }; var g = a(1245), f = a(7422), b = a(8375), v = a(5453), y = a(2759), k = a(3362), j = a(2184), C = a(2357), w = a(7015), A = a(656), N = a(7473), S = a(6230), L = a(435), T = a(3730), I = a(6919), M = a(355), H = a(9584); a(3863); var B = a(7262); a(9269), a(7464); var E = a(561), R = a(2910), P = a(9245), D = a(4578), O = a(318), z = a(9672), F = a(3654); let U = O.hj.create({ name: "selection", addProseMirrorPlugins() { let { editor: e } = this; return [new z.Sy({ key: new z.H$("selection"), props: { decorations: t => t.selection.empty || !0 === e.isFocused ? null : F.EH.create(t.doc, [F.p.inline(t.selection.from, t.selection.to, { class: "selection" })]) } })] } }); var W = a(1231), q = a(8009); let V = c.forwardRef((e, t) => { let { active: a, buttonSize: n = "medium", children: l, disabled: r, variant: s = "primary", className: o, activeClassname: c, ...d } = e, u = tu("flex group items-center justify-center border border-transparent gap-2 text-sm font-semibold rounded-md disabled:opacity-50 whitespace-nowrap", "primary" === s && tu("text-white bg-black border-black dark:text-black dark:bg-white dark:border-white", !r && !a && "hover:bg-neutral-800 active:bg-neutral-900 dark:hover:bg-neutral-200 dark:active:bg-neutral-300", a && tu("bg-neutral-900 dark:bg-neutral-300", c)), "secondary" === s && tu("text-neutral-900 dark:text-white", !r && !a && "hover:bg-neutral-100 active:bg-neutral-200 dark:hover:bg-neutral-900 dark:active:bg-neutral-800", a && "bg-neutral-200 dark:bg-neutral-800"), "tertiary" === s && tu("bg-neutral-50 text-neutral-900 dark:bg-neutral-900 dark:text-white dark:border-neutral-900", !r && !a && "hover:bg-neutral-100 active:bg-neutral-200 dark:hover:bg-neutral-800 dark:active:bg-neutral-700", a && tu("bg-neutral-200 dark:bg-neutral-800", c)), "ghost" === s && tu("bg-transparent border-transparent text-neutral-500 dark:text-neutral-400", !r && !a && "hover:bg-black/5 hover:text-neutral-700 active:bg-black/10 active:text-neutral-800 dark:hover:bg-white/10 dark:hover:text-neutral-300 dark:active:text-neutral-200", a && tu("bg-black/10 text-neutral-800 dark:bg-white/20 dark:text-neutral-200", c)), "medium" === n && "py-2 px-3", "small" === n && "py-1 px-2", "icon" === n && "w-8 h-8", "iconSmall" === n && "w-6 h-6", o); return (0, i.jsx)("button", { ref: t, disabled: r, className: u, ...d, children: l }) }); V.displayName = "Button"; var Z = a(9542); let _ = e => { let { label: t } = e; return (0, i.jsxs)("div", { className: "flex flex-col items-center justify-center gap-2 p-4 text-white bg-black rounded-lg shadow-2xl dark:text-black dark:bg-white", children: [(0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: "w-8 h-8 animate-spin", children: (0, i.jsx)("path", { d: "M21 12a9 9 0 1 1-6.219-8.56" }) }), t && (0, i.jsx)("p", { className: "text-sm font-semibold leading-tight text-white dark:text-black", children: t })] }) }, K = e => { let { hasOverlay: t = !0, label: a } = e; return t ? (0, Z.createPortal)((0, i.jsx)("div", { className: "items-center justify-center bg-black/60 flex h-full w-full fixed top-0 left-0 select-none z-[9999]", children: (0, i.jsx)(_, { label: a }) }), document.body) : (0, i.jsx)(_, { label: a }) }; var J = a(9143); let $ = (0, c.forwardRef)((e, t) => { let { children: a, className: n, withShadow: l = !0, withBorder: r = !0, ...s } = e, o = tu(n, "bg-white rounded-lg dark:bg-black", l ? "shadow-sm" : "", r ? "border border-neutral-200 dark:border-neutral-800" : ""); return (0, i.jsx)("div", { className: o, ...s, ref: t, children: a }) }); $.displayName = "Surface"; let G = (0, c.forwardRef)((e, t) => { let { asChild: a, className: n, children: l, spacing: r, noShadow: s, ...o } = e, c = tu("p-2", "small" === r && "p-[0.2rem]", n), d = a ? J.g7 : "div"; return (0, i.jsx)(d, { ref: t, ...o, children: (0, i.jsx)($, { className: c, withShadow: !s, children: l }) }) }); G.displayName = "Panel", (0, c.forwardRef)((e, t) => { let { asChild: a, className: n, children: l, ...r } = e, s = tu("border-b border-b-black/10 mb-2 pb-2", n), o = a ? J.g7 : "div"; return (0, i.jsx)(o, { className: s, ...r, ref: t, children: l }) }).displayName = "PanelDivider", (0, c.forwardRef)((e, t) => { let { asChild: a, className: n, children: l, ...r } = e, s = tu("border-b border-b-black/10 text-sm mb-2 pb-2", n), o = a ? J.g7 : "div"; return (0, i.jsx)(o, { className: s, ...r, ref: t, children: l }) }).displayName = "PanelHeader", (0, c.forwardRef)((e, t) => { let { asChild: a, className: n, children: l, ...r } = e, s = tu("mt-4 first:mt-1", n), o = a ? J.g7 : "div"; return (0, i.jsx)(o, { className: s, ...r, ref: t, children: l }) }).displayName = "PanelSection"; let Y = (0, c.forwardRef)((e, t) => { let { asChild: a, className: n, children: l, ...r } = e, s = tu("text-black/80 dark:text-white/80 text-xs font-medium mb-2 ml-1.5", n), o = a ? J.g7 : "div"; return (0, i.jsx)(o, { className: s, ...r, ref: t, children: l }) }); Y.displayName = "PanelHeadline", (0, c.forwardRef)((e, t) => { let { asChild: a, className: n, children: l, ...r } = e, s = tu("border-t border-black/10 text-sm mt-2 pt-2", n), o = a ? J.g7 : "div"; return (0, i.jsx)(o, { className: s, ...r, ref: t, children: l }) }).displayName = "PanelFooter"; let X = (0, c.forwardRef)((e, t) => { let { className: a, ...n } = e, l = tu("bg-black/5 border-0 rounded-lg caret-black block text-black text-sm font-medium h-[4.5rem] px-2 py-1 w-full", "dark:bg-white/10 dark:text-white dark:caret-white", "hover:bg-black/10", "dark:hover:bg-white/20", "focus:bg-transparent active:bg-transparent focus:outline focus:outline-black active:outline active:outline-black", "dark:focus:outline-white dark:active:outline-white", a); return (0, i.jsx)("textarea", { className: l, ref: t, ...n }) }); X.displayName = "Textarea"; let Q = [{ name: "arabic", label: "Arabic", value: "ar" }, { name: "chinese", label: "Chinese", value: "zh" }, { name: "english", label: "English", value: "en" }, { name: "french", label: "French", value: "fr" }, { name: "german", label: "German", value: "de" }, { name: "greek", label: "Greek", value: "gr" }, { name: "italian", label: "Italian", value: "it" }, { name: "japanese", label: "Japanese", value: "jp" }, { name: "korean", label: "Korean", value: "ko" }, { name: "russian", label: "Russian", value: "ru" }, { name: "spanish", label: "Spanish", value: "es" }, { name: "swedish", label: "Swedish", value: "sv" }, { name: "ukrainian", label: "Ukrainian", value: "ua" }], ee = [{ name: "academic", label: "Academic", value: "academic" }, { name: "business", label: "Business", value: "business" }, { name: "casual", label: "Casual", value: "casual" }, { name: "childfriendly", label: "Childfriendly", value: "childfriendly" }, { name: "conversational", label: "Conversational", value: "conversational" }, { name: "emotional", label: "Emotional", value: "emotional" }, { name: "humorous", label: "Humorous", value: "humorous" }, { name: "informative", label: "Informative", value: "informative" }, { name: "inspirational", label: "Inspirational", value: "inspirational" }, { name: "memeify", label: "Memeify", value: "meme" }, { name: "narrative", label: "Narrative", value: "narrative" }, { name: "objective", label: "Objective", value: "objective" }, { name: "persuasive", label: "Persuasive", value: "persuasive" }, { name: "poetic", label: "Poetic", value: "poetic" }], et = ["Lea Thompson", "Cyndi Lauper", "Tom Cruise", "Madonna", "Jerry Hall", "Joan Collins", "Winona Ryder", "Christina Applegate", "Alyssa Milano", "Molly Ringwald", "Ally Sheedy", "Debbie Harry", "Olivia Newton-John", "Elton John", "Michael J. Fox", "Axl Rose", "Emilio Estevez", "Ralph Macchio", "Rob Lowe", "Jennifer Grey", "Mickey Rourke", "John Cusack", "Matthew Broderick", "Justine Bateman", "Lisa Bonet"], ea = ["#fb7185", "#fdba74", "#d9f99d", "#a7f3d0", "#a5f3fc", "#a5b4fc", "#f0abfc"], en = ["#fb7185", "#fdba74", "#d9f99d", "#a7f3d0", "#a5f3fc", "#a5b4fc"]; var el = a(8913), er = a(3470); let ei = navigator.platform.toUpperCase().indexOf("MAC") >= 0, es = e => { let { children: t } = e, a = "inline-flex items-center justify-center w-5 h-5 p-1 text-[0.625rem] rounded font-semibold leading-none border border-neutral-200 text-neutral-500 border-b-2"; return "Mod" === t ? (0, i.jsx)("kbd", { className: a, children: ei ? "⌘" : "Ctrl" }) : "Shift" === t ? (0, i.jsx)("kbd", { className: a, children: "⇧" }) : "Alt" === t ? (0, i.jsx)("kbd", { className: a, children: ei ? "⌥" : "Alt" }) : (0, i.jsx)("kbd", { className: a, children: t }) }; var eo = e => { let { children: t, enabled: a = !0, title: n, shortcut: l, tippyOptions: r = {} } = e, s = (0, c.useCallback)(e => (0, i.jsxs)("span", { className: "flex items-center gap-2 px-2.5 py-1 bg-white border border-neutral-100 rounded-lg shadow-sm z-[999]", tabIndex: -1, "data-placement": e["data-placement"], "data-reference-hidden": e["data-reference-hidden"], "data-escaped": e["data-escaped"], children: [n && (0, i.jsx)("span", { className: "text-xs font-medium text-neutral-500", children: n }), l && (0, i.jsx)("span", { className: "flex items-center gap-0.5", children: l.map(e => (0, i.jsx)(es, { children: e }, e)) })] }), [l, n]); return a ? (0, i.jsx)(er.ZP, { delay: 500, offset: [0, 8], touch: !1, zIndex: 99999, appendTo: document.body, ...r, render: s, children: (0, i.jsx)("span", { children: t }) }) : (0, i.jsx)(i.Fragment, { children: t }) }; let ec = (0, c.forwardRef)((e, t) => { let { shouldShowContent: a = !0, children: n, isVertical: l = !1, className: r, ...s } = e, o = tu("text-black inline-flex h-full leading-none gap-0.5", l ? "flex-col p-2" : "flex-row p-1 items-center", r); return a && (0, i.jsx)($, { className: o, ...s, ref: t, children: n }) }); ec.displayName = "Toolbar"; let ed = (0, c.forwardRef)((e, t) => { let { horizontal: a, className: n, ...l } = e, r = tu("bg-neutral-200 dark:bg-neutral-800", a ? "w-full min-w-[1.5rem] h-[1px] my-1 first:mt-0 last:mt-0" : "h-full min-h-[1.5rem] w-[1px] mx-1 first:ml-0 last:mr-0", n); return (0, i.jsx)("div", { className: r, ref: t, ...l }) }); ed.displayName = "Toolbar.Divider"; let eu = (0, c.forwardRef)((e, t) => { let { children: a, buttonSize: n = "icon", variant: l = "ghost", className: r, tooltip: s, tooltipShortcut: o, activeClassname: c, ...d } = e, u = tu("gap-1 min-w-[2rem] px-2 w-auto", r), p = (0, i.jsx)(V, { activeClassname: c, className: u, variant: l, buttonSize: n, ref: t, ...d, children: a }); return s ? (0, i.jsx)(eo, { title: s, shortcut: o, children: p }) : p }); eu.displayName = "ToolbarButton"; let ep = { Wrapper: ec, Divider: ed, Button: eu }, em = e => { let { children: t } = e; return (0, i.jsx)("div", { className: "text-[.65rem] font-semibold mb-1 uppercase text-neutral-500 dark:text-neutral-400 px-1.5", children: t }) }, eh = e => { let { children: t, isActive: a, onClick: n, disabled: l, className: r } = e, s = tu("flex items-center gap-2 p-1.5 text-sm font-medium text-neutral-500 dark:text-neutral-400 text-left bg-transparent w-full rounded", !a && !l, "hover:bg-neutral-100 hover:text-neutral-800 dark:hover:bg-neutral-900 dark:hover:text-neutral-200", a && !l && "bg-neutral-100 text-neutral-800 dark:bg-neutral-900 dark:text-neutral-200", l && "text-neutral-400 cursor-not-allowed dark:text-neutral-600", r); return (0, i.jsx)("button", { className: s, disabled: l, onClick: n, children: t }) }, ex = e => { let { editor: t, node: a, getPos: n, deleteNode: l } = e, r = t.extensionManager.extensions.find(e => "ai" === e.name).options, [s, o] = (0, c.useState)({ text: "", tone: void 0, textLength: void 0, addHeading: !1, language: void 0 }), d = ee.find(e => e.value === s.tone), [p, m] = (0, c.useState)(void 0), [h, x] = (0, c.useState)(!1), g = (0, c.useMemo)(() => (0, W.Z)(), []), f = (0, c.useCallback)(async () => { let { text: e, tone: t, textLength: a, textUnit: n, addHeading: l, language: i } = s; if (!s.text) { q.ZP.error("Please enter a description"); return } x(!0); try { let { baseUrl: s, appId: o, token: c } = r, d = await fetch("".concat(s, "/text/prompt"), { method: "POST", headers: { accept: "application.json", "Content-Type": "application/json", "X-App-Id": o.trim(), Authorization: "Bearer ".concat(c.trim()) }, body: JSON.stringify({ text: e, textLength: a, textUnit: n, useHeading: l, tone: t, language: i }) }), u = (await d.json()).response; if (!u.length) { x(!1); return } m(u), x(!1) } catch (t) { var o, c; let e = null == t ? void 0 : null === (c = t.response) || void 0 === c ? void 0 : null === (o = c.data) || void 0 === o ? void 0 : o.error; x(!1), q.ZP.error("An error occurred" !== e ? "An error has occured: ".concat(e) : e) } }, [s, r]), b = (0, c.useCallback)(() => { let e = n(), l = e + a.nodeSize; t.chain().focus().insertContentAt({ from: e, to: l }, p).run() }, [t, p, n, a.nodeSize]), v = (0, c.useCallback)(() => { l() }, [l]), y = (0, c.useCallback)(e => { o(t => ({ ...t, text: e.target.value })) }, []), k = (0, c.useCallback)(() => { o(e => ({ ...e, tone: void 0 })) }, []), j = (0, c.useCallback)(e => () => { o(t => ({ ...t, tone: e.value })) }, []); return (0, i.jsx)(u.T5, { "data-drag-handle": !0, children: (0, i.jsx)(G, { noShadow: !0, className: "w-full", children: (0, i.jsxs)("div", { className: "flex flex-col p-1", children: [h && (0, i.jsx)(K, { label: "AI is now doing its job!" }), p && (0, i.jsxs)(i.Fragment, { children: [(0, i.jsx)(Y, { children: "Preview" }), (0, i.jsx)("div", { className: "bg-white dark:bg-black border-l-4 border-neutral-100 dark:border-neutral-700 text-black dark:text-white text-base max-h-[14rem] mb-4 ml-2.5 overflow-y-auto px-4 relative", dangerouslySetInnerHTML: { __html: p } })] }), (0, i.jsx)("div", { className: "flex flex-row items-center justify-between gap-1", children: (0, i.jsx)(Y, { asChild: !0, children: (0, i.jsx)("label", { htmlFor: g, children: "Prompt" }) }) }), (0, i.jsx)(X, { id: g, value: s.text, onChange: y, placeholder: "Tell me what you want me to write about.", required: !0, className: "mb-2" }), (0, i.jsxs)("div", { className: "flex flex-row items-center justify-between gap-1", children: [(0, i.jsx)("div", { className: "flex justify-between w-auto gap-1", children: (0, i.jsxs)(el.fC, { children: [(0, i.jsx)(el.xz, { asChild: !0, children: (0, i.jsxs)(V, { variant: "tertiary", children: [(0, i.jsx)(th, { name: "Mic" }), (null == d ? void 0 : d.label) || "Change tone", (0, i.jsx)(th, { name: "ChevronDown" })] }) }), (0, i.jsx)(el.Uv, { children: (0, i.jsx)(el.VY, { side: "bottom", align: "start", asChild: !0, children: (0, i.jsxs)($, { className: "p-2 min-w-[12rem]", children: [!!s.tone && (0, i.jsxs)(i.Fragment, { children: [(0, i.jsx)(el.ck, { asChild: !0, children: (0, i.jsxs)(eh, { isActive: void 0 === s.tone, onClick: k, children: [(0, i.jsx)(th, { name: "Undo2" }), "Reset"] }) }), (0, i.jsx)(ep.Divider, { horizontal: !0 })] }), ee.map(e => (0, i.jsx)(el.ck, { asChild: !0, children: (0, i.jsx)(eh, { isActive: e.value === s.tone, onClick: j(e), children: e.label }) }, e.value))] }) }) })] }) }), (0, i.jsxs)("div", { className: "flex justify-between w-auto gap-1", children: [p && (0, i.jsxs)(V, { variant: "ghost", className: "text-red-500 hover:bg-red-500/10 hover:text-red-500", onClick: v, children: [(0, i.jsx)(th, { name: "Trash" }), "Discard"] }), p && (0, i.jsxs)(V, { variant: "ghost", onClick: b, disabled: !p, children: [(0, i.jsx)(th, { name: "Check" }), "Insert"] }), (0, i.jsxs)(V, { variant: "primary", onClick: f, style: { whiteSpace: "nowrap" }, children: [p ? (0, i.jsx)(th, { name: "Repeat" }) : (0, i.jsx)(th, { name: "Sparkles" }), p ? "Regenerate" : "Generate text"] })] })] })] }) }) }) }, eg = O.NB.create({ name: "aiWriter", group: "block", draggable: !0, addOptions() { return { authorId: void 0, authorName: void 0, HTMLAttributes: { class: "node-".concat(this.name) } } }, addAttributes: () => ({ id: { default: void 0, parseHTML: e => e.getAttribute("data-id"), renderHTML: e => ({ "data-id": e.id }) }, authorId: { default: void 0, parseHTML: e => e.getAttribute("data-author-id"), renderHTML: e => ({ "data-author-id": e.authorId }) }, authorName: { default: void 0, parseHTML: e => e.getAttribute("data-author-name"), renderHTML: e => ({ "data-author-name": e.authorName }) } }), parseHTML() { return [{ tag: "div.node-".concat(this.name) }] }, renderHTML(e) { let { HTMLAttributes: t } = e; return ["div", (0, O.P1)(this.options.HTMLAttributes, t)] }, addCommands() { return { setAiWriter: () => e => { let { chain: t } = e; return t().focus().insertContent({ type: this.name, attrs: { id: (0, W.Z)(), authorId: this.options.authorId, authorName: this.options.authorName } }).run() } } }, addNodeView: () => (0, u.fW)(ex) }), ef = [{ name: "photorealistic", label: "Photorealistic", value: "photorealistic" }, { name: "digital-art", label: "Digital art", value: "digital_art" }, { name: "comic-book", label: "Comic book", value: "comic_book" }, { name: "neon-punk", label: "Neon punk", value: "neon_punk" }, { name: "isometric", label: "Isometric", value: "isometric" }, { name: "line-art", label: "Line art", value: "line_art" }, { name: "3d-model", label: "3D model", value: "3d_model" }], eb = e => { let { editor: t, node: a, getPos: n, deleteNode: l } = e, r = t.extensionManager.extensions.find(e => "ai" === e.name).options, [s, o] = (0, c.useState)({ text: "", imageStyle: void 0 }), d = ef.find(e => e.value === s.imageStyle), [p, m] = (0, c.useState)(void 0), [h, x] = (0, c.useState)(!1), g = (0, c.useMemo)(() => (0, W.Z)(), []), f = (0, c.useCallback)(async () => { if (!s.text) { q.ZP.error("Please enter a description for the image"); return } x(!0); let e = { text: s.text, style: s.imageStyle }; try { let { baseUrl: t, appId: a, token: n } = r, l = await fetch("".concat(t, "/image/prompt"), { method: "POST", headers: { accept: "application.json", "Content-Type": "application/json", "X-App-Id": a.trim(), Authorization: "Bearer ".concat(n.trim()) }, body: JSON.stringify(e) }), i = (await l.json()).response; if (!i.length) return; m(i), x(!1) } catch (n) { var t, a; let e = null == n ? void 0 : null === (a = n.response) || void 0 === a ? void 0 : null === (t = a.data) || void 0 === t ? void 0 : t.error; x(!1), q.ZP.error("An error occurred" !== e ? "An error has occured: ".concat(e) : e) } }, [s, r]), b = (0, c.useCallback)(() => { (null == p ? void 0 : p.length) && (t.chain().insertContent('<img src="'.concat(p, '" alt="" />')).deleteRange({ from: n(), to: n() }).focus().run(), x(!1)) }, [t, p, n]), v = (0, c.useCallback)(() => { l() }, [l]), y = (0, c.useCallback)(e => o(t => ({ ...t, text: e.target.value })), []), k = (0, c.useCallback)(() => { o(e => ({ ...e, imageStyle: void 0 })), m(void 0) }, []), j = (0, c.useCallback)(e => () => o(t => ({ ...t, imageStyle: e.value })), []); return (0, i.jsx)(u.T5, { "data-drag-handle": !0, children: (0, i.jsx)(G, { noShadow: !0, className: "w-full", children: (0, i.jsxs)("div", { className: "flex flex-col p-1", children: [h && (0, i.jsx)(K, { label: "AI is now doing its job!" }), p && (0, i.jsxs)(i.Fragment, { children: [(0, i.jsx)(Y, { children: "Preview" }), (0, i.jsx)("div", { className: "w-full mb-4 bg-white bg-center bg-no-repeat bg-contain border border-black rounded dark:border-neutral-700 aspect-square", style: { backgroundImage: "url(".concat(p, ")") } })] }), (0, i.jsx)("div", { className: "flex items-center justify-between gap-2 row", children: (0, i.jsx)(Y, { asChild: !0, children: (0, i.jsx)("label", { htmlFor: g, children: "Prompt" }) }) }), (0, i.jsx)(X, { id: g, value: s.text, onChange: y, placeholder: "Describe the image that you want me to generate.", required: !0, className: "mb-2" }), (0, i.jsxs)("div", { className: "flex flex-row items-center justify-between gap-1", children: [(0, i.jsx)("div", { className: "flex justify-between w-auto gap-1", children: (0, i.jsxs)(el.fC, { children: [(0, i.jsx)(el.xz, { asChild: !0, children: (0, i.jsxs)(V, { variant: "tertiary", children: [(0, i.jsx)(th, { name: "Image" }), (null == d ? void 0 : d.label) || "Image style", (0, i.jsx)(th, { name: "ChevronDown" })] }) }), (0, i.jsx)(el.Uv, { children: (0, i.jsx)(el.VY, { side: "bottom", align: "start", asChild: !0, children: (0, i.jsxs)($, { className: "p-2 min-w-[12rem]", children: [!!s.imageStyle && (0, i.jsxs)(i.Fragment, { children: [(0, i.jsxs)(eh, { isActive: void 0 === s.imageStyle, onClick: k, children: [(0, i.jsx)(th, { name: "Undo2" }), "Reset"] }), (0, i.jsx)(ep.Divider, { horizontal: !0 })] }), ef.map(e => (0, i.jsx)(eh, { isActive: e.value === s.imageStyle, onClick: j(e), children: e.label }, e.value))] }) }) })] }) }), (0, i.jsxs)("div", { className: "flex flex-row items-center justify-between gap-1", children: [p && (0, i.jsxs)(V, { variant: "ghost", className: "text-red-500 hover:bg-red-500/10 hover:text-red-500", onClick: v, children: [(0, i.jsx)(th, { name: "Trash" }), "Discard"] }), p && (0, i.jsxs)(V, { variant: "ghost", onClick: b, children: [(0, i.jsx)(th, { name: "Check" }), "Insert"] }), (0, i.jsxs)(V, { variant: "primary", onClick: f, children: [p ? (0, i.jsx)(th, { name: "Repeat" }) : (0, i.jsx)(th, { name: "Sparkles" }), p ? "Regenerate" : "Generate image"] })] })] })] }) }) }) }, ev = O.NB.create({ name: "aiImage", group: "block", draggable: !0, addOptions() { return { authorId: void 0, authorName: void 0, HTMLAttributes: { class: "node-".concat(this.name) } } }, addAttributes: () => ({ id: { default: void 0, parseHTML: e => e.getAttribute("data-id"), renderHTML: e => ({ "data-id": e.id }) }, authorId: { default: void 0, parseHTML: e => e.getAttribute("data-author-id"), renderHTML: e => ({ "data-author-id": e.authorId }) }, authorName: { default: void 0, parseHTML: e => e.getAttribute("data-author-name"), renderHTML: e => ({ "data-author-name": e.authorName }) } }), parseHTML() { return [{ tag: "div.node-".concat(this.name) }] }, renderHTML(e) { let { HTMLAttributes: t } = e; return ["div", (0, O.P1)(this.options.HTMLAttributes, t)] }, addCommands() { return { setAiImage: () => e => { let { chain: t } = e; return t().focus().insertContent({ type: this.name, attrs: { id: (0, W.Z)(), authorId: this.options.authorId, authorName: this.options.authorName } }).run() } } }, addNodeView: () => (0, u.fW)(eb) }), ey = a(5579).ZP.configure({ resizable: !0, lastColumnResizable: !1 }); var ek = a(9463); let ej = e => t => { let a = ek.rU.get(t.$anchorCell.node(-1)), n = t.$anchorCell.start(-1), l = a.cellsInRect(e), r = a.cellsInRect(a.rectBetween(t.$anchorCell.pos - n, t.$headCell.pos - n)); for (let e = 0, t = l.length; e < t; e += 1)if (-1 === r.indexOf(l[e])) return !1; return !0 }, eC = e => (0, O.Kk)(e => e.type.spec.tableRole && "table" === e.type.spec.tableRole)(e), ew = e => e instanceof ek.Xc, eA = e => t => !!ew(t) && ej({ left: e, right: e + 1, top: 0, bottom: ek.rU.get(t.$anchorCell.node(-1)).height })(t), eN = e => t => !!ew(t) && ej({ left: 0, right: ek.rU.get(t.$anchorCell.node(-1)).width, top: e, bottom: e + 1 })(t), eS = e => { if (ew(e)) { let t = ek.rU.get(e.$anchorCell.node(-1)); return ej({ left: 0, right: t.width, top: 0, bottom: t.height })(e) } return !1 }, eL = e => t => { let a = eC(t); if (a) { let t = ek.rU.get(a.node); return (Array.isArray(e) ? e : Array.from([e])).reduce((e, n) => { if (n >= 0 && n <= t.width - 1) { let l = t.cellsInRect({ left: n, right: n + 1, top: 0, bottom: t.height }); return e.concat(l.map(e => { let t = a.node.nodeAt(e), n = e + a.start; return { pos: n, start: n + 1, node: t } })) } return e }, []) } return null }, eT = e => t => { let a = eC(t); if (a) { let t = ek.rU.get(a.node); return (Array.isArray(e) ? e : Array.from([e])).reduce((e, n) => { if (n >= 0 && n <= t.height - 1) { let l = t.cellsInRect({ left: 0, right: t.width, top: n, bottom: n + 1 }); return e.concat(l.map(e => { let t = a.node.nodeAt(e), n = e + a.start; return { pos: n, start: n + 1, node: t } })) } return e }, []) } return null }, eI = e => t => a => { let n = eC(a.selection), l = "row" === e; if (n) { let e = ek.rU.get(n.node); if (t >= 0 && t < (l ? e.height : e.width)) { let r = l ? 0 : t, i = l ? t : 0, s = l ? e.width : t + 1, o = l ? t + 1 : e.height, c = e.cellsInRect({ left: r, top: i, right: l ? s : r + 1, bottom: l ? i + 1 : o }), d = o - i == 1 ? c : e.cellsInRect({ left: l ? r : s - 1, top: l ? o - 1 : i, right: s, bottom: o }), u = n.start + c[0], p = n.start + d[d.length - 1], m = a.doc.resolve(u), h = a.doc.resolve(p); return a.setSelection(new ek.Xc(h, m)) } } return a }, eM = eI("column"), eH = eI("row"), eB = O.NB.create({ name: "tableCell", content: "block+", tableRole: "cell", isolating: !0, addOptions: () => ({ HTMLAttributes: {} }), parseHTML: () => [{ tag: "td" }], renderHTML(e) { let { HTMLAttributes: t } = e; return ["td", (0, O.P1)(this.options.HTMLAttributes, t), 0] }, addAttributes: () => ({ colspan: { default: 1, parseHTML: e => { let t = e.getAttribute("colspan"); return t ? parseInt(t, 10) : 1 } }, rowspan: { default: 1, parseHTML: e => { let t = e.getAttribute("rowspan"); return t ? parseInt(t, 10) : 1 } }, colwidth: { default: null, parseHTML: e => { let t = e.getAttribute("colwidth"); return t ? [parseInt(t, 10)] : null } }, style: { default: null } }), addProseMirrorPlugins() { let { isEditable: e } = this.editor; return [new z.Sy({ props: { decorations: t => { if (!e) return F.EH.empty; let { doc: a, selection: n } = t, l = [], r = eL(0)(n); return r && r.forEach((e, t) => { let { pos: a } = e; l.push(F.p.widget(a + 1, () => { let e = eN(t)(n), a = "grip-row"; e && (a += " selected"), 0 === t && (a += " first"), t === r.length - 1 && (a += " last"); let l = document.createElement("a"); return l.className = a, l.addEventListener("mousedown", e => { e.preventDefault(), e.stopImmediatePropagation(), this.editor.view.dispatch(eH(t)(this.editor.state.tr)) }), l })) }), F.EH.create(a, l) } } })] } }), eE = a(4667).Z.extend({ allowGapCursor: !1, content: "tableCell*" }), eR = a(1059).Z.extend({ addAttributes: () => ({ colspan: { default: 1 }, rowspan: { default: 1 }, colwidth: { default: null, parseHTML: e => { let t = e.getAttribute("colwidth"); return t ? t.split(",").map(e => parseInt(e, 10)) : null } }, style: { default: null } }), addProseMirrorPlugins() { let { isEditable: e } = this.editor; return [new z.Sy({ props: { decorations: t => { if (!e) return F.EH.empty; let { doc: a, selection: n } = t, l = [], r = eT(0)(n); return r && r.forEach((e, t) => { let { pos: a } = e; l.push(F.p.widget(a + 1, () => { let e = eA(t)(n), a = "grip-column"; e && (a += " selected"), 0 === t && (a += " first"), t === r.length - 1 && (a += " last"); let l = document.createElement("a"); return l.className = a, l.addEventListener("mousedown", e => { e.preventDefault(), e.stopImmediatePropagation(), this.editor.view.dispatch(eM(t)(this.editor.state.tr)) }), l })) }), F.EH.create(a, l) } } })] } }), eP = a(406).Z.extend({ renderHTML() { return ["div", (0, O.P1)(this.options.HTMLAttributes, { "data-type": this.name }), ["hr"]] } }), eD = a(7211).Z.extend({ renderHTML(e) { let { node: t, HTMLAttributes: a } = e, n = parseInt(t.attrs.level, 10), l = this.options.levels.includes(n) ? n : this.options.levels[0]; return ["h".concat(l), (0, O.P1)(this.options.HTMLAttributes, a), 0] } }), eO = a(3787).B.extend({ content: "(block|columns)+" }); function ez(e) { let { types: t, node: a } = e; return Array.isArray(t) && t.includes(a.type) || a.type === t } let eF = O.hj.create({ name: "trailingNode", addOptions: () => ({ node: "paragraph", notAfter: ["paragraph"] }), addProseMirrorPlugins() { let e = new z.H$(this.name), t = Object.entries(this.editor.schema.nodes).map(e => { let [, t] = e; return t }).filter(e => this.options.notAfter.includes(e.name)); return [new z.Sy({ key: e, appendTransaction: (t, a, n) => { let { doc: l, tr: r, schema: i } = n, s = e.getState(n), o = l.content.size, c = i.nodes[this.options.node]; if (s) return r.insert(o, c.create()) }, state: { init: (e, a) => !ez({ node: a.tr.doc.lastChild, types: t }), apply: (e, a) => e.docChanged ? !ez({ node: e.doc.lastChild, types: t }) : a } })] } }); var eU = a(3718), eW = a(9918); let eq = [{ name: "ai", title: "AI", commands: [{ name: "aiWriter", label: "AI Writer", iconName: "Sparkles", description: "Let AI finish your thoughts", shouldBeHidden: e => e.isActive("columns"), action: e => e.chain().focus().setAiWriter().run() }, { name: "aiImage", label: "AI Image", iconName: "Sparkles", description: "Generate an image from text", shouldBeHidden: e => e.isActive("columns"), action: e => e.chain().focus().setAiImage().run() }] }, { name: "format", title: "Format", commands: [{ name: "heading1", label: "Heading 1", iconName: "Heading1", description: "High priority section title", aliases: ["h1"], action: e => { e.chain().focus().setHeading({ level: 1 }).run() } }, { name: "heading2", label: "Heading 2", iconName: "Heading2", description: "Medium priority section title", aliases: ["h2"], action: e => { e.chain().focus().setHeading({ level: 2 }).run() } }, { name: "heading3", label: "Heading 3", iconName: "Heading3", description: "Low priority section title", aliases: ["h3"], action: e => { e.chain().focus().setHeading({ level: 3 }).run() } }, { name: "bulletList", label: "Bullet List", iconName: "List", description: "Unordered list of items", aliases: ["ul"], action: e => { e.chain().focus().toggleBulletList().run() } }, { name: "numberedList", label: "Numbered List", iconName: "ListOrdered", description: "Ordered list of items", aliases: ["ol"], action: e => { e.chain().focus().toggleOrderedList().run() } }, { name: "taskList", label: "Task List", iconName: "ListTodo", description: "Task list with todo items", aliases: ["todo"], action: e => { e.chain().focus().toggleTaskList().run() } }, { name: "blockquote", label: "Blockquote", iconName: "Quote", description: "Element for quoting", action: e => { e.chain().focus().setBlockquote().run() } }, { name: "codeBlock", label: "Code Block", iconName: "SquareCode", description: "Code block with syntax highlighting", shouldBeHidden: e => e.isActive("columns"), action: e => { e.chain().focus().setCodeBlock().run() } }] }, { name: "insert", title: "Insert", commands: [{ name: "table", label: "Table", iconName: "Table", description: "Insert a table", shouldBeHidden: e => e.isActive("columns"), action: e => { e.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: !1 }).run() } }, { name: "image", label: "Image", iconName: "Image", description: "Insert an image", aliases: ["img"], action: e => { e.chain().focus().setImageUpload().run() } }, { name: "columns", label: "Columns", iconName: "Columns", description: "Add two column content", aliases: ["cols"], shouldBeHidden: e => e.isActive("columns"), action: e => { e.chain().focus().setColumns().focus(e.state.selection.head - 1).run() } }, { name: "horizontalRule", label: "Horizontal Rule", iconName: "Minus", description: "Insert a horizontal divider", aliases: ["hr"], action: e => { e.chain().focus().setHorizontalRule().run() } }, { name: "toc", label: "Table of Contents", iconName: "Book", aliases: ["outline"], description: "Insert a table of contents", shouldBeHidden: e => e.isActive("columns"), action: e => { e.chain().focus().insertTableOfContents().run() } }] }], eV = c.forwardRef((e, t) => { let a = (0, c.useRef)(null), n = (0, c.useRef)(null), [l, r] = (0, c.useState)(0), [s, o] = (0, c.useState)(0); (0, c.useEffect)(() => { r(0), o(0) }, [e.items]); let d = (0, c.useCallback)((t, a) => { let n = e.items[t].commands[a]; e.command(n) }, [e]); c.useImperativeHandle(t, () => ({ onKeyDown: t => { let { event: a } = t; if ("ArrowDown" === a.key) { if (!e.items.length) return !1; let t = e.items[l].commands, a = s + 1, n = l; return t.length - 1 < a && (a = 0, n = l + 1), e.items.length - 1 < n && (n = 0), o(a), r(n), !0 } if ("ArrowUp" === a.key) { if (!e.items.length) return !1; let t = s - 1, a = l; if (t < 0) { var n; a = l - 1, t = (null === (n = e.items[a]) || void 0 === n ? void 0 : n.commands.length) - 1 || 0 } return a < 0 && (a = e.items.length - 1, t = e.items[a].commands.length - 1), o(t), r(a), !0 } return "Enter" === a.key && !!e.items.length && -1 !== l && -1 !== s && (d(l, s), !0) } })), (0, c.useEffect)(() => { if (n.current && a.current) { let e = n.current.offsetTop, t = n.current.offsetHeight; a.current.scrollTop = e - t } }, [s, l]); let u = (0, c.useCallback)((e, t) => () => { d(e, t) }, [d]); return e.items.length ? (0, i.jsx)($, { ref: a, className: "text-black max-h-[min(80vh,24rem)] overflow-auto flex-wrap mb-8 p-2", children: (0, i.jsx)("div", { className: "grid grid-cols-1 gap-0.5", children: e.items.map((e, t) => (0, i.jsxs)(c.Fragment, { children: [(0, i.jsx)("div", { className: "text-neutral-500 text-[0.65rem] col-[1/-1] mx-2 mt-4 font-semibold tracking-wider select-none uppercase first:mt-0.5", children: e.title }, "".concat(e.title)), e.commands.map((e, a) => (0, i.jsxs)(eh, { isActive: l === t && s === a, onClick: u(t, a), children: [(0, i.jsx)(th, { name: e.iconName, className: "mr-1" }), e.label] }, "".concat(e.label)))] }, "".concat(e.title, "-wrapper"))) }) }) : null }); eV.displayName = "MenuList"; let eZ = "slashCommand", e_ = O.hj.create({ name: eZ, priority: 200, onCreate() { n = (0, eW.ZP)("body", { interactive: !0, trigger: "manual", placement: "bottom-start", theme: "slash-command", maxWidth: "16rem", offset: [16, 8], popperOptions: { strategy: "fixed", modifiers: [{ name: "flip", enabled: !1 }] } }) }, addProseMirrorPlugins() { return [(0, eU.ZP)({ editor: this.editor, char: "/", allowSpaces: !0, startOfLine: !0, pluginKey: new z.H$(eZ), allow: e => { var t, a, n; let { state: l, range: r } = e, i = l.doc.resolve(r.from), s = 1 === i.depth, o = "paragraph" === i.parent.type.name, c = (null === (t = i.parent.textContent) || void 0 === t ? void 0 : t.charAt(0)) === "/", d = this.editor.isActive("column"), u = null === (n = i.parent.textContent) || void 0 === n ? void 0 : n.substring(null === (a = i.parent.textContent) || void 0 === a ? void 0 : a.indexOf("/")), p = !(null == u ? void 0 : u.endsWith("  ")); return (s && o && c || d && o && c) && p }, command: e => { var t, a, n; let { editor: l, props: r } = e, { view: i, state: s } = l, { $head: o, $from: c } = i.state.selection, d = c.pos, u = (null == o ? void 0 : o.nodeBefore) ? d - (null !== (n = null === (a = o.nodeBefore.text) || void 0 === a ? void 0 : a.substring(null === (t = o.nodeBefore.text) || void 0 === t ? void 0 : t.indexOf("/")).length) && void 0 !== n ? n : 0) : c.start(), p = s.tr.deleteRange(u, d); i.dispatch(p), r.action(l), i.focus() }, items: e => { let { query: t } = e; return eq.map(e => ({ ...e, commands: e.commands.filter(e => { let a = e.label.toLowerCase().trim(), n = t.toLowerCase().trim(); if (e.aliases) { let t = e.aliases.map(e => e.toLowerCase().trim()); return a.includes(n) || t.includes(n) } return a.includes(n) }).filter(e => !e.shouldBeHidden || !e.shouldBeHidden(this.editor)) })).filter(e => e.commands.length > 0).map(e => ({ ...e, commands: e.commands.map(e => ({ ...e, isEnabled: !0 })) })) }, render: () => { let e; let t = null; return { onStart: a => { var l; e = new u.M_(eV, { props: a, editor: a.editor }); let { view: r } = a.editor, i = r.dom, s = () => { if (!a.clientRect) return a.editor.storage[eZ].rect; let t = a.clientRect(); if (!t) return a.editor.storage[eZ].rect; let n = t.y; if (t.top + e.element.offsetHeight + 40 > window.innerHeight) { let a = t.top + e.element.offsetHeight - window.innerHeight + 40; n = t.y - a } return i.getBoundingClientRect().x, new DOMRect(t.x, n, t.width, t.height) }; t = () => { null == n || n[0].setProps({ getReferenceClientRect: s }) }, null === (l = r.dom.parentElement) || void 0 === l || l.addEventListener("scroll", t), null == n || n[0].setProps({ getReferenceClientRect: s, appendTo: () => document.body, content: e.element }), null == n || n[0].show() }, onUpdate(t) { var a; e.updateProps(t); let { view: l } = t.editor; l.dom; let r = () => { if (!t.clientRect) return t.editor.storage[eZ].rect; let e = t.clientRect(); return e ? new DOMRect(e.x, e.y, e.width, e.height) : t.editor.storage[eZ].rect }; null === (a = l.dom.parentElement) || void 0 === a || a.addEventListener("scroll", () => { null == n || n[0].setProps({ getReferenceClientRect: r }) }), t.editor.storage[eZ].rect = t.clientRect ? r() : { width: 0, height: 0, left: 0, top: 0, right: 0, bottom: 0 }, null == n || n[0].setProps({ getReferenceClientRect: r }) }, onKeyDown(t) { var a; return "Escape" === t.event.key ? (null == n || n[0].hide(), !0) : ((null == n ? void 0 : n[0].state.isShown) || null == n || n[0].show(), null === (a = e.ref) || void 0 === a ? void 0 : a.onKeyDown(t)) }, onExit(a) { if (null == n || n[0].hide(), t) { var l; let { view: e } = a.editor; null === (l = e.dom.parentElement) || void 0 === l || l.removeEventListener("scroll", t) } e.destroy() } } } })] }, addStorage: () => ({ rect: { width: 0, height: 0, left: 0, top: 0, right: 0, bottom: 0 } }) }), eK = O.hj.create({ name: "fontSize", addOptions: () => ({ types: ["textStyle"] }), addGlobalAttributes() { return [{ types: ["paragraph"], attributes: { class: {} } }, { types: this.options.types, attributes: { fontSize: { parseHTML: e => e.style.fontSize.replace(/['"]+/g, ""), renderHTML: e => e.fontSize ? { style: "font-size: ".concat(e.fontSize) } : {} } } }] }, addCommands: () => ({ setFontSize: e => t => { let { chain: a } = t; return a().setMark("textStyle", { fontSize: e }).run() }, unsetFontSize: () => e => { let { chain: t } = e; return t().setMark("textStyle", { fontSize: null }).removeEmptyTextStyle().run() } }) }), eJ = O.NB.create({ name: "figure", addOptions: () => ({ HTMLAttributes: {} }), group: "block", content: "block figcaption", draggable: !0, defining: !0, selectable: !0, parseHTML() { return [{ tag: 'figure[data-type="'.concat(this.name, '"]') }] }, renderHTML(e) { let { HTMLAttributes: t } = e; return ["figure", (0, O.P1)(t, { "data-type": this.name }), 0] }, addProseMirrorPlugins() { return [new z.Sy({ props: { handleDOMEvents: { dragstart: (e, t) => { if (!t.target) return !1; let a = e.posAtDOM(t.target, 0); return e.state.doc.resolve(a).parent.type.name === this.type.name && t.preventDefault(), !1 } } } })] } }), e$ = a(4826).Ee.extend({ group: "block" }), eG = O.NB.create({ name: "figcaption", addOptions: () => ({ HTMLAttributes: {} }), content: "inline*", selectable: !1, draggable: !1, marks: "link", parseHTML: () => [{ tag: "figcaption" }], addKeyboardShortcuts() { return { Enter: e => { let { editor: t } = e, { state: { selection: { $from: a, empty: n } } } = t; if (!n || a.parent.type !== this.type || a.parentOffset !== a.parent.nodeSize - 2) return !1; let l = t.state.selection.$from.end(); return t.chain().focus(l).insertContentAt(l, { type: "paragraph" }).run() }, Backspace: e => { let { editor: t } = e, { state: { selection: { $from: a, empty: n } } } = t; if (!n || a.parent.type !== this.type || 0 !== a.parentOffset) return !1; let l = t.state.doc.nodeAt(a.pos - 2); return (null == l ? void 0 : l.type.name) === e$.name } } }, renderHTML(e) { let { HTMLAttributes: t } = e; return ["figcaption", (0, O.P1)(t), 0] } }), eY = O.NB.create({ name: "quote", content: "paragraph+", defining: !0, marks: "", parseHTML: () => [{ tag: "blockquote" }], renderHTML(e) { let { HTMLAttributes: t } = e; return ["blockquote", t, 0] }, addKeyboardShortcuts: () => ({ Backspace: () => !1 }) }), eX = O.NB.create({ name: "quoteCaption", group: "block", content: "text*", defining: !0, isolating: !0, parseHTML: () => [{ tag: "figcaption" }], renderHTML(e) { let { HTMLAttributes: t } = e; return ["figcaption", t, 0] }, addKeyboardShortcuts() { return { Enter: e => { let { editor: t } = e, { state: { selection: { $from: a, empty: n } } } = t; if (!n || a.parent.type !== this.type || a.parentOffset !== a.parent.nodeSize - 2) return !1; let l = t.state.selection.$from.end(); return t.chain().focus(l).insertContentAt(l, { type: "paragraph" }).run() } } } }), eQ = eJ.extend({ name: "blockquoteFigure", group: "block", content: "quote quoteCaption", isolating: !0, addExtensions: () => [eY, eX], renderHTML(e) { let { HTMLAttributes: t } = e; return ["figure", (0, O.P1)(t, { "data-type": this.name }), ["div", {}, 0]] }, addKeyboardShortcuts: () => ({ Enter: () => !1 }), addAttributes() { var e; return { ...null === (e = this.parent) || void 0 === e ? void 0 : e.call(this) } }, addCommands() { return { setBlockquote: () => e => { let { state: t, chain: a } = e, n = t.selection.$from.start(), l = t.selection.content(); return a().focus().insertContent({ type: this.name, content: [{ type: "quote", content: l.content.toJSON() || [{ type: "paragraph", attrs: { textAlign: "left" } }] }, { type: "quoteCaption" }] }).focus(n + 1).run() } } } }), e0 = a(5646).ZP.extend({ inclusive: !1, parseHTML: () => [{ tag: 'a[href]:not([data-type="button"]):not([href *= "javascript:" i])' }], renderHTML(e) { let { HTMLAttributes: t } = e; return ["a", (0, O.P1)(this.options.HTMLAttributes, t, { class: "link" }), 0] }, addProseMirrorPlugins() { var e; let { editor: t } = this; return [...(null === (e = this.parent) || void 0 === e ? void 0 : e.call(this)) || [], new z.Sy({ props: { handleKeyDown: (e, a) => { let { selection: n } = t.state; return "Escape" === a.key && !0 !== n.empty && t.commands.focus(n.to, { scrollIntoView: !1 }), !1 } } })] } }), e1 = (0, c.forwardRef)((e, t) => { let { className: a, ...n } = e, l = tu("animate-spin rounded-full border-2 border-current border-t-transparent h-4 w-4", a); return (0, i.jsx)("div", { className: l, ref: t, ...n }) }); e1.displayName = "Spinner"; class e2 { } e2.uploadImage = async () => (await new Promise(e => setTimeout(e, 500)), "/placeholder-image.jpg"); let e5 = e => { let { onUpload: t } = e, [a, n] = (0, c.useState)(!1); return { loading: a, uploadFile: (0, c.useCallback)(async e => { n(!0); try { let e = await e2.uploadImage(); t(e) } catch (t) { var a, l; let e = (null == t ? void 0 : null === (l = t.response) || void 0 === l ? void 0 : null === (a = l.data) || void 0 === a ? void 0 : a.error) || "Something went wrong"; q.ZP.error(e) } n(!1) }, [t]) } }, e4 = () => { let e = (0, c.useRef)(null), t = (0, c.useCallback)(() => { var t; null === (t = e.current) || void 0 === t || t.click() }, []); return { ref: e, handleUploadClick: t } }, e8 = e => { let { uploader: t } = e, [a, n] = (0, c.useState)(!1), [l, r] = (0, c.useState)(!1); return (0, c.useEffect)(() => { let e = () => { n(!0) }, t = () => { n(!1) }; return document.body.addEventListener("dragstart", e), document.body.addEventListener("dragend", t), () => { document.body.removeEventListener("dragstart", e), document.body.removeEventListener("dragend", t) } }, []), { isDragging: a, draggedInside: l, onDragEnter: () => { r(!0) }, onDragLeave: () => { r(!1) }, onDrop: (0, c.useCallback)(e => { if (r(!1), 0 === e.dataTransfer.files.length) return; let a = e.dataTransfer.files, n = []; for (let e = 0; e < a.length; e += 1) { let t = a.item(e); t && n.push(t) } if (n.some(e => -1 === e.type.indexOf("image"))) return; e.preventDefault(); let l = n.filter(e => -1 !== e.type.indexOf("image")), i = l.length > 0 ? l[0] : void 0; i && t(i) }, [t]) } }, e9 = e => { let { onUpload: t } = e, { loading: a, uploadFile: n } = e5({ onUpload: t }), { handleUploadClick: l, ref: r } = e4(), { draggedInside: s, onDrop: o, onDragEnter: d, onDragLeave: u } = e8({ uploader: n }), p = (0, c.useCallback)(e => e.target.files ? n(e.target.files[0]) : null, [n]); if (a) return (0, i.jsx)("div", { className: "flex items-center justify-center p-8 rounded-lg min-h-[10rem] bg-opacity-80", children: (0, i.jsx)(e1, { className: "text-neutral-500", size: 1.5 }) }); let m = tu("flex flex-col items-center justify-center px-8 py-10 rounded-lg bg-opacity-80", s && "bg-neutral-100"); return (0, i.jsxs)("div", { className: m, onDrop: o, onDragOver: d, onDragLeave: u, contentEditable: !1, children: [(0, i.jsx)(th, { name: "Image", className: "w-12 h-12 mb-4 text-black dark:text-white opacity-20" }), (0, i.jsxs)("div", { className: "flex flex-col items-center justify-center gap-2", children: [(0, i.jsx)("div", { className: "text-sm font-medium text-center text-neutral-400 dark:text-neutral-500", children: s ? "Drop image here" : "Drag and drop or" }), (0, i.jsx)("div", { children: (0, i.jsxs)(V, { disabled: s, onClick: l, variant: "primary", buttonSize: "small", children: [(0, i.jsx)(th, { name: "Upload" }), "Upload an image"] }) })] }), (0, i.jsx)("input", { className: "w-0 h-0 overflow-hidden opacity-0", ref: r, type: "file", accept: ".jpg,.jpeg,.png,.webp,.gif", onChange: p })] }) }, e3 = e => { let { getPos: t, editor: a } = e, n = (0, c.useCallback)(e => { e && a.chain().setImageBlock({ src: e }).deleteRange({ from: t(), to: t() }).focus().run() }, [t, a]); return (0, i.jsx)(u.T5, { children: (0, i.jsx)("div", { className: "p-0 m-0", "data-drag-handle": !0, children: (0, i.jsx)(e9, { onUpload: n }) }) }) }, e7 = O.NB.create({ name: "imageUpload", isolating: !0, defining: !0, group: "block", draggable: !0, selectable: !0, inline: !1, parseHTML() { return [{ tag: 'div[data-type="'.concat(this.name, '"]') }] }, renderHTML() { return ["div", { "data-type": this.name }] }, addCommands() { return { setImageUpload: () => e => { let { commands: t } = e; return t.insertContent('<div data-type="'.concat(this.name, '"></div>')) } } }, addNodeView: () => (0, u.fW)(e3) }), e6 = e => { let { editor: t, getPos: a, node: n } = e, l = (0, c.useRef)(null), { src: r } = n.attrs, s = tu("left" === n.attrs.align ? "ml-0" : "ml-auto", "right" === n.attrs.align ? "mr-0" : "mr-auto", "center" === n.attrs.align && "mx-auto"), o = (0, c.useCallback)(() => { t.commands.setNodeSelection(a()) }, [a, t.commands]); return (0, i.jsx)(u.T5, { children: (0, i.jsx)("div", { className: s, style: { width: n.attrs.width }, children: (0, i.jsx)("div", { contentEditable: !1, ref: l, children: (0, i.jsx)("img", { className: "block", src: r, alt: "", onClick: o }) }) }) }) }, te = e$.extend({ name: "imageBlock", group: "block", defining: !0, isolating: !0, addAttributes: () => ({ src: { default: "", parseHTML: e => e.getAttribute("src"), renderHTML: e => ({ src: e.src }) }, width: { default: "100%", parseHTML: e => e.getAttribute("data-width"), renderHTML: e => ({ "data-width": e.width }) }, align: { default: "center", parseHTML: e => e.getAttribute("data-align"), renderHTML: e => ({ "data-align": e.align }) }, alt: { default: void 0, parseHTML: e => e.getAttribute("alt"), renderHTML: e => ({ alt: e.alt }) } }), parseHTML: () => [{ tag: 'img[src*="tiptap.dev"]:not([src^="data:"]), img[src*="windows.net"]:not([src^="data:"])' }], renderHTML(e) { let { HTMLAttributes: t } = e; return ["img", (0, O.P1)(this.options.HTMLAttributes, t)] }, addCommands: () => ({ setImageBlock: e => t => { let { commands: a } = t; return a.insertContent({ type: "imageBlock", attrs: { src: e.src } }) }, setImageBlockAt: e => t => { let { commands: a } = t; return a.insertContentAt(e.pos, { type: "imageBlock", attrs: { src: e.src } }) }, setImageBlockAlign: e => t => { let { commands: a } = t; return a.updateAttributes("imageBlock", { align: e }) }, setImageBlockWidth: e => t => { let { commands: a } = t; return a.updateAttributes("imageBlock", { width: "".concat(Math.max(0, Math.min(100, e)), "%") }) } }), addNodeView: () => (0, u.fW)(e6) }); (l = r || (r = {})).SidebarLeft = "sidebar-left", l.SidebarRight = "sidebar-right", l.TwoColumn = "two-column"; let tt = O.NB.create({ name: "columns", group: "columns", content: "column column", defining: !0, isolating: !0, addAttributes: () => ({ layout: { default: "two-column" } }), addCommands: () => ({ setColumns: () => e => { let { commands: t } = e; return t.insertContent('<div data-type="columns"><div data-type="column" data-position="left"><p></p></div><div data-type="column" data-position="right"><p></p></div></div>') }, setLayout: e => t => { let { commands: a } = t; return a.updateAttributes("columns", { layout: e }) } }), renderHTML(e) { let { HTMLAttributes: t } = e; return ["div", { "data-type": "columns", class: "layout-".concat(t.layout) }, 0] }, parseHTML: () => [{ tag: 'div[data-type="columns"]' }] }), ta = O.NB.create({ name: "column", content: "block+", isolating: !0, addAttributes: () => ({ position: { default: "", parseHTML: e => e.getAttribute("data-position"), renderHTML: e => ({ "data-position": e.position }) } }), renderHTML(e) { let { HTMLAttributes: t } = e; return ["div", (0, O.P1)(t, { "data-type": "column" }), 0] }, parseHTML: () => [{ tag: 'div[data-type="column"]' }] }), tn = (0, c.forwardRef)((e, t) => { let [a, n] = (0, c.useState)(0); (0, c.useEffect)(() => n(0), [e.items]); let l = (0, c.useCallback)(t => { let a = e.items[t]; a && e.command({ name: a.name }) }, [e]); (0, c.useImperativeHandle)(t, () => { let t = t => { let a = e.items[t]; if (a) { let e = document.querySelector('[data-emoji-name="'.concat(a.name, '"]')); e && e.scrollIntoView({ block: "nearest" }) } }, r = () => { let l = (a + e.items.length - 1) % e.items.length; n(l), t(l) }, i = () => { let l = (a + 1) % e.items.length; n(l), t(l) }, s = () => { l(a) }; return { onKeyDown: e => { let { event: t } = e; return "ArrowUp" === t.key ? (r(), !0) : "ArrowDown" === t.key ? (i(), !0) : "Enter" === t.key && (s(), !0) } } }, [e, a, l]); let r = (0, c.useCallback)(e => () => l(e), [l]); return e.items && e.items.length ? (0, i.jsx)(G, { className: "overflow-y-auto max-w-[18rem] max-h-[18rem]", children: e.items.map((e, t) => (0, i.jsxs)(V, { active: t === a, variant: "ghost", className: "justify-start w-full", buttonSize: "small", onClick: r(t), "data-emoji-name": e.name, children: [e.fallbackImage ? (0, i.jsx)("img", { src: e.fallbackImage, className: "w-5 h-5", alt: "emoji" }) : e.emoji, " ", (0, i.jsxs)("span", { className: "truncate text-ellipsis", children: [":", e.name, ":"] })] }, e.name)) }) : null }); tn.displayName = "EmojiList"; let tl = { items: e => { let { editor: t, query: a } = e; return t.storage.emoji.emojis.filter(e => { let { shortcodes: t, tags: n } = e; return t.find(e => e.startsWith(a.toLowerCase())) || n.find(e => e.startsWith(a.toLowerCase())) }).slice(0, 250) }, allowSpaces: !1, render: () => { let e, t; return { onStart: a => { e = new u.M_(tn, { props: a, editor: a.editor }), t = (0, eW.ZP)("body", { getReferenceClientRect: a.clientRect, appendTo: () => document.body, content: e.element, showOnCreate: !0, interactive: !0, trigger: "manual", placement: "bottom-start" }) }, onUpdate(a) { e.updateProps(a), t[0].setProps({ getReferenceClientRect: a.clientRect }) }, onKeyDown(a) { var n, l; return "Escape" === a.event.key ? (t[0].hide(), e.destroy(), !0) : null !== (l = null === (n = e.ref) || void 0 === n ? void 0 : n.onKeyDown(a)) && void 0 !== l && l }, onExit() { t[0].destroy(), e.destroy() } } } }, tr = (0, c.memo)(e => { let { editor: t, onItemClick: a } = e, [n, l] = (0, c.useState)(null); return (0, c.useEffect)(() => { let e = e => { let { editor: t } = e; l({ ...t.extensionStorage.tableOfContents }) }; return e({ editor: t }), t.on("update", e), t.on("selectionUpdate", e), () => { t.off("update", e), t.off("selectionUpdate", e) } }, [t]), (0, i.jsxs)(i.Fragment, { children: [(0, i.jsx)("div", { className: "mb-2 text-xs font-semibold uppercase text-neutral-500 dark:text-neutral-400", children: "Table of contents" }), n && n.content.length > 0 ? (0, i.jsx)("div", { className: "flex flex-col gap-1", children: n.content.map(e => (0, i.jsxs)("a", { href: "#".concat(e.id), style: { marginLeft: "".concat(1 * e.level - 1, "rem") }, onClick: a, className: tu("block font-medium text-neutral-500 dark:text-neutral-300 p-1 rounded bg-opacity-10 text-sm hover:text-neutral-800 transition-all hover:bg-black hover:bg-opacity-5 truncate w-full", e.isActive && "text-neutral-800 bg-neutral-100 dark:text-neutral-100 dark:bg-neutral-900"), children: [e.itemIndex, ". ", e.textContent] }, e.id)) }) : (0, i.jsx)("div", { className: "text-sm text-neutral-500", children: "Start adding headlines to your document …" })] }) }); tr.displayName = "TableOfContents"; let ti = e => { let { editor: t } = e; return (0, i.jsx)(u.T5, { children: (0, i.jsx)("div", { className: "p-2 -m-2 rounded-lg", contentEditable: !1, children: (0, i.jsx)(tr, { editor: t }) }) }) }, ts = O.NB.create({ name: "tableOfContentsNode", group: "block", atom: !0, selectable: !0, draggable: !0, inline: !1, parseHTML: () => [{ tag: 'div[data-type="table-of-content"]' }], renderHTML(e) { let { HTMLAttributes: t } = e; return ["div", { ...t, "data-type": "table-of-content" }] }, addNodeView: () => (0, u.fW)(ti), addCommands() { return { insertTableOfContents: () => e => { let { commands: t } = e; return t.insertContent({ type: this.name }) } } } }), to = e => { let t = e; for (; t && !["TD", "TH"].includes(t.tagName);)t = t.parentElement; let a = t && t.querySelector && t.querySelector("a.grip-column.selected"), n = t && t.querySelector && t.querySelector("a.grip-row.selected"); return !!a || !!n }, tc = (e, t) => [eP.name, te.name, e7.name, B.dn.name, te.name, e0.name, eg.name, ev.name, eG.name, ts.name].some(t => e.isActive(t)) || to(t), td = e => { let { editor: t } = e, { state: { doc: a, selection: n, selection: { empty: l, from: r, to: i } } } = t, s = !a.textBetween(r, i).length && (0, O.xh)(n); return !l && !s && !!t.isEditable }; function tu() { for (var e = arguments.length, t = Array(e), a = 0; a < e; a++)t[a] = arguments[a]; return (0, m.m)((0, p.W)(t)) } function tp(e) { return e[Math.floor(Math.random() * e.length)] } var tm = a(5364); let th = (0, c.memo)(e => { let { name: t, className: a, strokeWidth: n } = e, l = tm[t]; return l ? (0, i.jsx)(l, { className: tu("w-4 h-4", a), strokeWidth: n || 2.5 }) : null }); th.displayName = "Icon"; let tx = e => { let { onClear: t, onEdit: a, url: n } = e; return (0, i.jsxs)($, { className: "flex items-center gap-2 p-2", children: [(0, i.jsx)("a", { href: n, target: "_blank", rel: "noopener noreferrer", className: "text-sm underline break-all", children: n }), (0, i.jsx)(ep.Divider, {}), (0, i.jsx)(eo, { title: "Edit link", children: (0, i.jsx)(ep.Button, { onClick: a, children: (0, i.jsx)(th, { name: "Pen" }) }) }), (0, i.jsx)(eo, { title: "Remove link", children: (0, i.jsx)(ep.Button, { onClick: t, children: (0, i.jsx)(th, { name: "Trash2" }) }) })] }) }; var tg = a(1461); let tf = (0, c.memo)(e => { let { color: t, active: a, onColorChange: n } = e, l = tu("flex items-center justify-center px-1.5 py-1.5 rounded group", !a && "hover:bg-neutral-100", a && "bg-neutral-100"), r = tu("w-4 h-4 rounded bg-slate-100 shadow-sm ring-offset-2 ring-current", !a && "hover:ring-1", a && "ring-1"), s = (0, c.useCallback)(() => { n && n(t || "") }, [n, t]); return (0, i.jsx)("button", { onClick: s, className: l, children: (0, i.jsx)("div", { style: { backgroundColor: t, color: t }, className: r }) }) }); tf.displayName = "ColorButton"; let tb = e => { let { onChange: t, active: a = !1, size: n = "large" } = e, l = a ? "checked" : "unchecked", r = a ? "on" : "off", s = tu("inline-flex cursor-pointer items-center rounded-full border-transparent transition-colors", a ? "bg-black" : "bg-neutral-200 hover:bg-neutral-300", a ? "dark:bg-white" : "dark:bg-neutral-800 dark:hover:bg-neutral-700", "small" === n && "h-3 w-6 px-0.5", "large" === n && "h-5 w-9 px-0.5"), o = tu("rounded-full pointer-events-none block transition-transform", "bg-white dark:bg-black", "small" === n && "h-2 w-2", "large" === n && "h-4 w-4", a ? tu("small" === n ? "translate-x-3" : "", "large" === n ? "translate-x-4" : "") : "translate-x-0"), d = (0, c.useCallback)(() => { t(!a) }, [a, t]); return (0, i.jsx)("button", { className: s, type: "button", role: "switch", "aria-checked": a, "data-state": l, value: r, onClick: d, children: (0, i.jsx)("span", { className: o, "data-state": l }) }) }, tv = e => { let { initialUrl: t, initialOpenInNewTab: a, onSetLink: n } = e, [l, r] = (0, c.useState)(t || ""), [i, s] = (0, c.useState)(a || !1), o = (0, c.useCallback)(e => { r(e.target.value) }, []), d = (0, c.useMemo)(() => /^(\S+):(\/\/)?\S+$/.test(l), [l]), u = (0, c.useCallback)(e => { e.preventDefault(), d && n(l, i) }, [l, d, i, n]); return { url: l, setUrl: r, openInNewTab: i, setOpenInNewTab: s, onChange: o, handleSubmit: u, isValidUrl: d } }, ty = e => { let { onSetLink: t, initialOpenInNewTab: a, initialUrl: n } = e, l = tv({ onSetLink: t, initialOpenInNewTab: a, initialUrl: n }); return (0, i.jsxs)($, { className: "p-2", children: [(0, i.jsxs)("form", { onSubmit: l.handleSubmit, className: "flex items-center gap-2", children: [(0, i.jsxs)("label", { className: "flex items-center gap-2 p-2 rounded-lg bg-neutral-100 dark:bg-neutral-900 cursor-text", children: [(0, i.jsx)(th, { name: "Link", className: "flex-none text-black dark:text-white" }), (0, i.jsx)("input", { type: "url", className: "flex-1 bg-transparent outline-none min-w-[12rem] text-black text-sm dark:text-white", placeholder: "Enter URL", value: l.url, onChange: l.onChange })] }), (0, i.jsx)(V, { variant: "primary", buttonSize: "small", type: "submit", disabled: !l.isValidUrl, children: "Set Link" })] }), (0, i.jsx)("div", { className: "mt-3", children: (0, i.jsxs)("label", { className: "flex items-center justify-start gap-2 text-sm font-semibold cursor-pointer select-none text-neutral-500 dark:text-neutral-400", children: ["Open in new tab", (0, i.jsx)(tb, { active: l.openInNewTab, onChange: l.setOpenInNewTab })] }) })] }) }, tk = e => { let { editor: t, appendTo: a } = e, [n, l] = (0, c.useState)(!1), r = (0, c.useCallback)(() => t.isActive("link"), [t]), { href: s, target: o } = t.getAttributes("link"), d = (0, c.useCallback)(() => { l(!0) }, []), p = (0, c.useCallback)((e, a) => { t.chain().focus().extendMarkRange("link").setLink({ href: e, target: a ? "_blank" : "" }).run(), l(!1) }, [t]), m = (0, c.useCallback)(() => (t.chain().focus().extendMarkRange("link").unsetLink().run(), l(!1), null), [t]); return (0, c.useCallback)(() => { l(!0) }, []), (0, c.useCallback)(() => { l(!1) }, []), (0, i.jsx)(u.NM, { editor: t, pluginKey: "textMenu", shouldShow: r, updateDelay: 0, tippyOptions: { popperOptions: { modifiers: [{ name: "flip", enabled: !1 }] }, appendTo: () => null == a ? void 0 : a.current, onHidden: () => { l(!1) } }, children: n ? (0, i.jsx)(ty, { initialUrl: s, initialOpenInNewTab: "_blank" === o, onSetLink: p }) : (0, i.jsx)(tx, { url: s, onClear: m, onEdit: d }) }) }, tj = e => { let t = (0, c.useCallback)(() => e.chain().focus().toggleBold().run(), [e]), a = (0, c.useCallback)(() => e.chain().focus().toggleItalic().run(), [e]), n = (0, c.useCallback)(() => e.chain().focus().toggleStrike().run(), [e]), l = (0, c.useCallback)(() => e.chain().focus().toggleUnderline().run(), [e]), r = (0, c.useCallback)(() => e.chain().focus().toggleCode().run(), [e]), i = (0, c.useCallback)(() => e.chain().focus().toggleCodeBlock().run(), [e]), s = (0, c.useCallback)(() => e.chain().focus().toggleSubscript().run(), [e]), o = (0, c.useCallback)(() => e.chain().focus().toggleSuperscript().run(), [e]), d = (0, c.useCallback)(() => e.chain().focus().setTextAlign("left").run(), [e]), u = (0, c.useCallback)(() => e.chain().focus().setTextAlign("center").run(), [e]), p = (0, c.useCallback)(() => e.chain().focus().setTextAlign("right").run(), [e]), m = (0, c.useCallback)(() => e.chain().focus().setTextAlign("justify").run(), [e]), h = (0, c.useCallback)(t => e.chain().setColor(t).run(), [e]), x = (0, c.useCallback)(() => e.chain().focus().unsetColor().run(), [e]), g = (0, c.useCallback)(t => e.chain().setHighlight({ color: t }).run(), [e]), f = (0, c.useCallback)(() => e.chain().focus().unsetHighlight().run(), [e]), b = (0, c.useCallback)(() => e.chain().focus().aiSimplify().run(), [e]), v = (0, c.useCallback)(() => e.chain().focus().aiEmojify().run(), [e]), y = (0, c.useCallback)(() => e.chain().focus().aiComplete().run(), [e]), k = (0, c.useCallback)(() => e.chain().focus().aiFixSpellingAndGrammar().run(), [e]), j = (0, c.useCallback)(() => e.chain().focus().aiExtend().run(), [e]), C = (0, c.useCallback)(() => e.chain().focus().aiShorten().run(), [e]), w = (0, c.useCallback)(() => e.chain().focus().aiTldr().run(), [e]), A = (0, c.useCallback)(t => e.chain().focus().aiAdjustTone(t).run(), [e]), N = (0, c.useCallback)(t => e.chain().focus().aiTranslate(t).run(), [e]), S = (0, c.useCallback)((t, a) => e.chain().focus().setLink({ href: t, target: a ? "_blank" : "" }).run(), [e]); return { onBold: t, onItalic: a, onStrike: n, onUnderline: l, onCode: r, onCodeBlock: i, onSubscript: s, onSuperscript: o, onAlignLeft: d, onAlignCenter: u, onAlignRight: p, onAlignJustify: m, onChangeColor: h, onClearColor: x, onChangeHighlight: g, onClearHighlight: f, onSetFont: (0, c.useCallback)(t => t && 0 !== t.length ? e.chain().focus().setFontFamily(t).run() : e.chain().focus().unsetFontFamily().run(), [e]), onSetFontSize: (0, c.useCallback)(t => t && 0 !== t.length ? e.chain().focus().setFontSize(t).run() : e.chain().focus().unsetFontSize().run(), [e]), onSimplify: b, onEmojify: v, onCompleteSentence: y, onFixSpelling: k, onMakeLonger: j, onMakeShorter: C, onTldr: w, onTone: A, onTranslate: N, onLink: S } }, tC = e => { var t, a, n, l; let r = (0, c.useCallback)(t => { let { view: a, from: n } = t; if (!a) return !1; let l = a.domAtPos(n || 0).node; return !tc(e, a.nodeDOM(n || 0) || l) && td({ editor: e }) }, [e]); return { isBold: e.isActive("bold"), isItalic: e.isActive("italic"), isStrike: e.isActive("strike"), isUnderline: e.isActive("underline"), isCode: e.isActive("code"), isSubscript: e.isActive("subscript"), isSuperscript: e.isActive("superscript"), isAlignLeft: e.isActive({ textAlign: "left" }), isAlignCenter: e.isActive({ textAlign: "center" }), isAlignRight: e.isActive({ textAlign: "right" }), isAlignJustify: e.isActive({ textAlign: "justify" }), currentColor: (null === (t = e.getAttributes("textStyle")) || void 0 === t ? void 0 : t.color) || void 0, currentHighlight: (null === (a = e.getAttributes("highlight")) || void 0 === a ? void 0 : a.color) || void 0, currentFont: (null === (n = e.getAttributes("textStyle")) || void 0 === n ? void 0 : n.fontFamily) || void 0, currentSize: (null === (l = e.getAttributes("textStyle")) || void 0 === l ? void 0 : l.fontSize) || void 0, shouldShow: r } }; var tw = a(7427); let tA = [{ label: "Sans Serif", options: [{ label: "Inter", value: "" }, { label: "Arial", value: "Arial" }, { label: "Helvetica", value: "Helvetica" }] }, { label: "Serif", options: [{ label: "Times New Roman", value: "Times" }, { label: "Garamond", value: "Garamond" }, { label: "Georgia", value: "Georgia" }] }, { label: "Monospace", options: [{ label: "Courier", value: "Courier" }, { label: "Courier New", value: "Courier New" }] }], tN = tA.flatMap(e => [e.options]).flat(), tS = [{ label: "Smaller", value: "12px" }, { label: "Small", value: "14px" }, { label: "Medium", value: "" }, { label: "Large", value: "18px" }, { label: "Extra Large", value: "24px" }], tL = e => (0, c.useMemo)(() => [{ type: "category", label: "Hierarchy", id: "hierarchy" }, { icon: "Pilcrow", onClick: () => e.chain().focus().lift("taskItem").liftListItem("listItem").setParagraph().run(), id: "paragraph", disabled: () => !e.can().setParagraph(), isActive: () => e.isActive("paragraph") && !e.isActive("orderedList") && !e.isActive("bulletList") && !e.isActive("taskList"), label: "Paragraph", type: "option" }, { icon: "Heading1", onClick: () => e.chain().focus().lift("taskItem").liftListItem("listItem").setHeading({ level: 1 }).run(), id: "heading1", disabled: () => !e.can().setHeading({ level: 1 }), isActive: () => e.isActive("heading", { level: 1 }), label: "Heading 1", type: "option" }, { icon: "Heading2", onClick: () => e.chain().focus().lift("taskItem").liftListItem("listItem").setHeading({ level: 2 }).run(), id: "heading2", disabled: () => !e.can().setHeading({ level: 2 }), isActive: () => e.isActive("heading", { level: 2 }), label: "Heading 2", type: "option" }, { icon: "Heading3", onClick: () => e.chain().focus().lift("taskItem").liftListItem("listItem").setHeading({ level: 3 }).run(), id: "heading3", disabled: () => !e.can().setHeading({ level: 3 }), isActive: () => e.isActive("heading", { level: 3 }), label: "Heading 3", type: "option" }, { type: "category", label: "Lists", id: "lists" }, { icon: "List", onClick: () => e.chain().focus().toggleBulletList().run(), id: "bulletList", disabled: () => !e.can().toggleBulletList(), isActive: () => e.isActive("bulletList"), label: "Bullet list", type: "option" }, { icon: "ListOrdered", onClick: () => e.chain().focus().toggleOrderedList().run(), id: "orderedList", disabled: () => !e.can().toggleOrderedList(), isActive: () => e.isActive("orderedList"), label: "Numbered list", type: "option" }, { icon: "ListTodo", onClick: () => e.chain().focus().toggleTaskList().run(), id: "todoList", disabled: () => !e.can().toggleTaskList(), isActive: () => e.isActive("taskList"), label: "Todo list", type: "option" }], [e, e.state]), tT = e => "option" === e.type, tI = e => "category" === e.type, tM = e => { let { onCompleteSentence: t, onEmojify: a, onFixSpelling: n, onMakeLonger: l, onMakeShorter: r, onSimplify: s, onTldr: o, onTone: d, onTranslate: u } = e, p = (0, c.useCallback)(e => () => d(e), [d]), m = (0, c.useCallback)(e => () => u(e), [u]); return (0, i.jsxs)(el.fC, { children: [(0, i.jsx)(el.xz, { asChild: !0, children: (0, i.jsxs)(ep.Button, { className: "text-purple-500 hover:text-purple-600 active:text-purple-600 dark:text-purple-400 dark:hover:text-purple-300 dark:active:text-purple-400", activeClassname: "text-purple-600 hover:text-purple-600 dark:text-purple-400 dark:hover:text-purple-200", children: [(0, i.jsx)(th, { name: "Sparkles", className: "mr-1" }), "AI Tools", (0, i.jsx)(th, { name: "ChevronDown", className: "w-2 h-2 ml-1" })] }) }), (0, i.jsx)(el.VY, { asChild: !0, children: (0, i.jsxs)($, { className: "p-2 min-w-[10rem]", children: [(0, i.jsx)(el.ck, { onClick: s, children: (0, i.jsxs)(eh, { children: [(0, i.jsx)(th, { name: "CircleSlash" }), "Simplify"] }) }), (0, i.jsx)(el.ck, { onClick: n, children: (0, i.jsxs)(eh, { children: [(0, i.jsx)(th, { name: "Eraser" }), "Fix spelling & grammar"] }) }), (0, i.jsx)(el.ck, { onClick: r, children: (0, i.jsxs)(eh, { children: [(0, i.jsx)(th, { name: "ArrowLeftToLine" }), "Make shorter"] }) }), (0, i.jsx)(el.ck, { onClick: l, children: (0, i.jsxs)(eh, { children: [(0, i.jsx)(th, { name: "ArrowRightToLine" }), "Make longer"] }) }), (0, i.jsxs)(el.Tr, { children: [(0, i.jsx)(el.fF, { children: (0, i.jsxs)(eh, { children: [(0, i.jsx)(th, { name: "Mic" }), "Change tone", (0, i.jsx)(th, { name: "ChevronRight", className: "w-4 h-4 ml-auto" })] }) }), (0, i.jsx)(el.tu, { children: (0, i.jsx)($, { className: "flex flex-col min-w-[15rem] p-2 max-h-[20rem] overflow-auto", children: ee.map(e => (0, i.jsx)(el.ck, { onClick: p(e.value), children: (0, i.jsx)(eh, { children: e.label }) }, e.value)) }) })] }), (0, i.jsx)(el.ck, { onClick: o, children: (0, i.jsxs)(eh, { children: [(0, i.jsx)(th, { name: "MoreHorizontal" }), "Tl;dr:"] }) }), (0, i.jsx)(el.ck, { onClick: a, children: (0, i.jsxs)(eh, { children: [(0, i.jsx)(th, { name: "SmilePlus" }), "Emojify"] }) }), (0, i.jsxs)(el.Tr, { children: [(0, i.jsx)(el.fF, { children: (0, i.jsxs)(eh, { children: [(0, i.jsx)(th, { name: "Languages" }), "Translate", (0, i.jsx)(th, { name: "ChevronRight", className: "w-4 h-4 ml-auto" })] }) }), (0, i.jsx)(el.tu, { children: (0, i.jsx)($, { className: "flex flex-col min-w-[15rem] p-2 max-h-[20rem] overflow-auto", children: Q.map(e => (0, i.jsx)(el.ck, { onClick: m(e.value), children: (0, i.jsx)(eh, { children: e.label }) }, e.value)) }) })] }), (0, i.jsx)(el.ck, { onClick: t, children: (0, i.jsxs)(eh, { children: [(0, i.jsx)(th, { name: "PenLine" }), "Complete sentence"] }) })] }) })] }) }, tH = e => { let { onSetLink: t } = e; return (0, i.jsxs)(tw.fC, { children: [(0, i.jsx)(tw.xz, { asChild: !0, children: (0, i.jsx)(ep.Button, { tooltip: "Set Link", children: (0, i.jsx)(th, { name: "Link" }) }) }), (0, i.jsx)(tw.VY, { children: (0, i.jsx)(ty, { onSetLink: t }) })] }) }, tB = (0, c.memo)(ep.Button), tE = (0, c.memo)(e => { let { color: t, onChange: a, onClear: n } = e, [l, r] = (0, c.useState)(t || ""), s = (0, c.useCallback)(e => { r(e.target.value) }, []), o = (0, c.useCallback)(() => { if (!/^#([0-9A-F]{3}){1,2}$/i.test(l)) { a && a(""); return } a && a(l) }, [l, a]); return (0, i.jsxs)("div", { className: "flex flex-col gap-2", children: [(0, i.jsx)(tg.gW, { className: "w-full", color: t || "", onChange: a }), (0, i.jsx)("input", { type: "text", className: "w-full p-2 text-black bg-white border rounded dark:bg-black dark:text-white border-neutral-200 dark:border-neutral-800 focus:outline-1 focus:ring-0 focus:outline-neutral-300 dark:focus:outline-neutral-700", placeholder: "#000000", value: l, onChange: s, onBlur: o }), (0, i.jsxs)("div", { className: "flex flex-wrap items-center gap-1 max-w-[15rem]", children: [en.map(e => (0, i.jsx)(tf, { active: e === t, color: e, onColorChange: a }, e)), (0, i.jsx)(ep.Button, { tooltip: "Reset color to default", onClick: n, children: (0, i.jsx)(th, { name: "Undo" }) })] })] }) }), tR = (0, c.memo)(e => { let { onChange: t, value: a } = e, n = tN.find(e => e.value === a), l = (null == n ? void 0 : n.label.split(" ")[0]) || "Inter", r = (0, c.useCallback)(e => () => t(e), [t]); return (0, i.jsxs)(el.fC, { children: [(0, i.jsx)(el.xz, { asChild: !0, children: (0, i.jsxs)(ep.Button, { active: !!(null == n ? void 0 : n.value), children: [l, (0, i.jsx)(th, { name: "ChevronDown", className: "w-2 h-2" })] }) }), (0, i.jsx)(el.VY, { asChild: !0, children: (0, i.jsx)($, { className: "flex flex-col gap-1 px-2 py-4", children: tA.map(e => (0, i.jsxs)("div", { className: "mt-2.5 first:mt-0 gap-0.5 flex flex-col", children: [(0, i.jsx)(em, { children: e.label }), e.options.map(e => (0, i.jsx)(eh, { isActive: a === e.value, onClick: r(e.value), children: (0, i.jsx)("span", { style: { fontFamily: e.value }, children: e.label }) }, "".concat(e.label, "_").concat(e.value)))] }, e.label)) }) })] }) }), tP = (0, c.memo)(e => { let { onChange: t, value: a } = e, n = tS.find(e => e.value === a), l = (null == n ? void 0 : n.label.split(" ")[0]) || "Medium", r = (0, c.useCallback)(e => () => t(e), [t]); return (0, i.jsxs)(el.fC, { children: [(0, i.jsx)(el.xz, { asChild: !0, children: (0, i.jsxs)(ep.Button, { active: !!(null == n ? void 0 : n.value), children: [l, (0, i.jsx)(th, { name: "ChevronDown", className: "w-2 h-2" })] }) }), (0, i.jsx)(el.VY, { asChild: !0, children: (0, i.jsx)($, { className: "flex flex-col gap-1 px-2 py-4", children: tS.map(e => (0, i.jsx)(eh, { isActive: a === e.value, onClick: r(e.value), children: (0, i.jsx)("span", { style: { fontSize: e.value }, children: e.label }) }, "".concat(e.label, "_").concat(e.value))) }) })] }) }), tD = (0, c.memo)(e => { let { options: t } = e, a = (0, c.useMemo)(() => t.find(e => "option" === e.type && e.isActive()), [t]); return (0, i.jsxs)(el.fC, { children: [(0, i.jsx)(el.xz, { asChild: !0, children: (0, i.jsxs)(ep.Button, { active: (null == a ? void 0 : a.id) !== "paragraph" && !!(null == a ? void 0 : a.type), children: [(0, i.jsx)(th, { name: (null == a ? void 0 : a.type) === "option" && a.icon || "Pilcrow" }), (0, i.jsx)(th, { name: "ChevronDown", className: "w-2 h-2" })] }) }), (0, i.jsx)(el.VY, { asChild: !0, children: (0, i.jsx)($, { className: "flex flex-col gap-1 px-2 py-4", children: t.map(e => tT(e) ? (0, i.jsxs)(eh, { onClick: e.onClick, isActive: e.isActive(), children: [(0, i.jsx)(th, { name: e.icon, className: "w-4 h-4 mr-1" }), e.label] }, e.id) : tI(e) ? (0, i.jsx)("div", { className: "mt-2 first:mt-0", children: (0, i.jsx)(em, { children: e.label }, e.id) }, e.id) : void 0) }) })] }) }), tO = e => { let { editor: t } = e, a = tj(t), n = tC(t), l = tL(t); return (0, i.jsx)(u.NM, { tippyOptions: { popperOptions: { placement: "top-start" } }, editor: t, pluginKey: "textMenu", shouldShow: n.shouldShow, updateDelay: 100, children: (0, i.jsxs)(ep.Wrapper, { children: [(0, i.jsx)(tM, { onCompleteSentence: a.onCompleteSentence, onEmojify: a.onEmojify, onFixSpelling: a.onFixSpelling, onMakeLonger: a.onMakeLonger, onMakeShorter: a.onMakeShorter, onSimplify: a.onSimplify, onTldr: a.onTldr, onTone: a.onTone, onTranslate: a.onTranslate }), (0, i.jsx)(ep.Divider, {}), (0, i.jsx)(tD, { options: l }), (0, i.jsx)(tR, { onChange: a.onSetFont, value: n.currentFont || "" }), (0, i.jsx)(tP, { onChange: a.onSetFontSize, value: n.currentSize || "" }), (0, i.jsx)(ep.Divider, {}), (0, i.jsx)(tB, { tooltip: "Bold", tooltipShortcut: ["Mod", "B"], onClick: a.onBold, active: n.isBold, children: (0, i.jsx)(th, { name: "Bold" }) }), (0, i.jsx)(tB, { tooltip: "Italic", tooltipShortcut: ["Mod", "I"], onClick: a.onItalic, active: n.isItalic, children: (0, i.jsx)(th, { name: "Italic" }) }), (0, i.jsx)(tB, { tooltip: "Underline", tooltipShortcut: ["Mod", "U"], onClick: a.onUnderline, active: n.isUnderline, children: (0, i.jsx)(th, { name: "Underline" }) }), (0, i.jsx)(tB, { tooltip: "Strikehrough", tooltipShortcut: ["Mod", "Shift", "S"], onClick: a.onStrike, active: n.isStrike, children: (0, i.jsx)(th, { name: "Strikethrough" }) }), (0, i.jsx)(tB, { tooltip: "Code", tooltipShortcut: ["Mod", "E"], onClick: a.onCode, active: n.isCode, children: (0, i.jsx)(th, { name: "Code" }) }), (0, i.jsx)(tB, { tooltip: "Code block", onClick: a.onCodeBlock, children: (0, i.jsx)(th, { name: "Code2" }) }), (0, i.jsx)(tH, { onSetLink: a.onLink }), (0, i.jsxs)(tw.fC, { children: [(0, i.jsx)(tw.xz, { asChild: !0, children: (0, i.jsx)(tB, { active: !!n.currentHighlight, tooltip: "Highlight text", children: (0, i.jsx)(th, { name: "Highlighter" }) }) }), (0, i.jsx)(tw.VY, { side: "top", sideOffset: 8, asChild: !0, children: (0, i.jsx)($, { className: "p-1", children: (0, i.jsx)(tE, { color: n.currentHighlight, onChange: a.onChangeHighlight, onClear: a.onClearHighlight }) }) })] }), (0, i.jsxs)(tw.fC, { children: [(0, i.jsx)(tw.xz, { asChild: !0, children: (0, i.jsx)(tB, { active: !!n.currentColor, tooltip: "Text color", children: (0, i.jsx)(th, { name: "Palette" }) }) }), (0, i.jsx)(tw.VY, { side: "top", sideOffset: 8, asChild: !0, children: (0, i.jsx)($, { className: "p-1", children: (0, i.jsx)(tE, { color: n.currentColor, onChange: a.onChangeColor, onClear: a.onClearColor }) }) })] }), (0, i.jsxs)(tw.fC, { children: [(0, i.jsx)(tw.xz, { asChild: !0, children: (0, i.jsx)(tB, { tooltip: "More options", children: (0, i.jsx)(th, { name: "MoreVertical" }) }) }), (0, i.jsx)(tw.VY, { side: "top", asChild: !0, children: (0, i.jsxs)(ep.Wrapper, { children: [(0, i.jsx)(tB, { tooltip: "Subscript", tooltipShortcut: ["Mod", "."], onClick: a.onSubscript, active: n.isSubscript, children: (0, i.jsx)(th, { name: "Subscript" }) }), (0, i.jsx)(tB, { tooltip: "Superscript", tooltipShortcut: ["Mod", ","], onClick: a.onSuperscript, active: n.isSuperscript, children: (0, i.jsx)(th, { name: "Superscript" }) }), (0, i.jsx)(ep.Divider, {}), (0, i.jsx)(tB, { tooltip: "Align left", tooltipShortcut: ["Shift", "Mod", "L"], onClick: a.onAlignLeft, active: n.isAlignLeft, children: (0, i.jsx)(th, { name: "AlignLeft" }) }), (0, i.jsx)(tB, { tooltip: "Align center", tooltipShortcut: ["Shift", "Mod", "E"], onClick: a.onAlignCenter, active: n.isAlignCenter, children: (0, i.jsx)(th, { name: "AlignCenter" }) }), (0, i.jsx)(tB, { tooltip: "Align right", tooltipShortcut: ["Shift", "Mod", "R"], onClick: a.onAlignRight, active: n.isAlignRight, children: (0, i.jsx)(th, { name: "AlignRight" }) }), (0, i.jsx)(tB, { tooltip: "Justify", tooltipShortcut: ["Shift", "Mod", "J"], onClick: a.onAlignJustify, active: n.isAlignJustify, children: (0, i.jsx)(th, { name: "AlignJustify" }) })] }) })] })] }) }) }; var tz = a(2039), tF = (e, t, a) => { let n = (0, c.useCallback)(() => { let n = e.chain(); n.setNodeSelection(a).unsetAllMarks(), (null == t ? void 0 : t.type.name) !== "paragraph" && n.setParagraph(), n.run() }, [e, a, null == t ? void 0 : t.type.name]), l = (0, c.useCallback)(() => { e.commands.setNodeSelection(a); let { $anchor: n } = e.state.selection, l = n.node(1) || e.state.selection.node; e.chain().setMeta("hideDragHandle", !0).insertContentAt(a + ((null == t ? void 0 : t.nodeSize) || 0), l.toJSON()).run() }, [e, a, null == t ? void 0 : t.nodeSize]); return { resetTextFormatting: n, duplicateNode: l, copyNodeToClipboard: (0, c.useCallback)(() => { e.chain().setMeta("hideDragHandle", !0).setNodeSelection(a).run(), document.execCommand("copy") }, [e, a]), deleteNode: (0, c.useCallback)(() => { e.chain().setMeta("hideDragHandle", !0).setNodeSelection(a).deleteSelection().run() }, [e, a]), handleAdd: (0, c.useCallback)(() => { if (-1 !== a) { var n; let l = a + ((null == t ? void 0 : t.nodeSize) || 0), r = (null == t ? void 0 : t.type.name) === "paragraph" && (null == t ? void 0 : null === (n = t.content) || void 0 === n ? void 0 : n.size) === 0, i = r ? a + 2 : l + 2; e.chain().command(e => { let { dispatch: t, tr: n, state: i } = e; return !t || (r ? n.insertText("/", a, a + 1) : n.insert(l, i.schema.nodes.paragraph.create(null, [i.schema.text("/")])), t(n)) }).focus(i).run() } }, [t, a, e]) } }; let tU = () => { let [e, t] = (0, c.useState)(null), [a, n] = (0, c.useState)(-1), l = (0, c.useCallback)(e => { e.node && t(e.node), n(e.pos) }, [n, t]); return { currentNode: e, currentNodePos: a, setCurrentNode: t, setCurrentNodePos: n, handleNodeChange: l } }, tW = e => { let { editor: t } = e, [a, n] = (0, c.useState)(!1), l = tU(), r = tF(t, l.currentNode, l.currentNodePos); return (0, c.useEffect)(() => { a ? t.commands.setMeta("lockDragHandle", !0) : t.commands.setMeta("lockDragHandle", !1) }, [t, a]), (0, i.jsx)(tz.Z, { pluginKey: "ContentItemMenu", editor: t, onNodeChange: l.handleNodeChange, tippyOptions: { offset: [-2, 16], zIndex: 99 }, children: (0, i.jsxs)("div", { className: "flex items-center gap-0.5", children: [(0, i.jsx)(ep.Button, { onClick: r.handleAdd, children: (0, i.jsx)(th, { name: "Plus" }) }), (0, i.jsxs)(tw.fC, { open: a, onOpenChange: n, children: [(0, i.jsx)(tw.xz, { asChild: !0, children: (0, i.jsx)(ep.Button, { children: (0, i.jsx)(th, { name: "GripVertical" }) }) }), (0, i.jsx)(tw.VY, { side: "bottom", align: "start", sideOffset: 8, children: (0, i.jsxs)($, { className: "p-2 flex flex-col min-w-[16rem]", children: [(0, i.jsx)(tw.x8, { children: (0, i.jsxs)(eh, { onClick: r.resetTextFormatting, children: [(0, i.jsx)(th, { name: "RemoveFormatting" }), "Clear formatting"] }) }), (0, i.jsx)(tw.x8, { children: (0, i.jsxs)(eh, { onClick: r.copyNodeToClipboard, children: [(0, i.jsx)(th, { name: "Clipboard" }), "Copy to clipboard"] }) }), (0, i.jsx)(tw.x8, { children: (0, i.jsxs)(eh, { onClick: r.duplicateNode, children: [(0, i.jsx)(th, { name: "Copy" }), "Duplicate"] }) }), (0, i.jsx)(ep.Divider, { horizontal: !0 }), (0, i.jsx)(tw.x8, { children: (0, i.jsxs)(eh, { onClick: r.deleteNode, className: "text-red-500 bg-red-500 dark:text-red-500 hover:bg-red-500 dark:hover:text-red-500 dark:hover:bg-red-500 bg-opacity-10 hover:bg-opacity-20 dark:hover:bg-opacity-20", children: [(0, i.jsx)(th, { name: "Trash2" }), "Delete"] }) })] }) })] })] }) }) }; var tq = a(7946), tV = a(8396), tZ = a(1263); let t_ = e => { var t; let { provider: a, userId: n, userName: l = "Maxi" } = e; return [eO, tt, P.a, R.Uf.configure({ nested: !0 }), eg.configure({ authorId: n, authorName: l }), ev.configure({ authorId: n, authorName: l }), ta, U, eD.configure({ levels: [1, 2, 3, 4, 5, 6] }), eP, g.V.configure({ document: !1, dropcursor: !1, heading: !1, horizontalRule: !1, blockquote: !1, history: !1, codeBlock: !1 }), tV.H.configure({ lowlight: tZ.$, defaultLanguage: null }), C.p, eK, w.b, N.I, eF, e0.configure({ openOnClick: !1 }), f.y$.configure({ multicolor: !0 }), v.v, b.H.configure({ limit: 5e4 }), M.o5, ts, e7.configure({ clientId: null == a ? void 0 : null === (t = a.document) || void 0 === t ? void 0 : t.clientID }), te, D.Xx.configure({ allowedMimeTypes: ["image/png", "image/jpeg", "image/gif", "image/webp"], onDrop: (e, t, a) => { t.forEach(async () => { let t = await e2.uploadImage(); e.chain().setImageBlockAt({ pos: a, src: t }).focus().run() }) }, onPaste: (e, t) => { t.forEach(async () => { let t = await e2.uploadImage(); return e.chain().setImageBlockAt({ pos: e.state.selection.anchor, src: t }).focus().run() }) } }), k.dy.configure({ enableEmoticons: !0, suggestion: tl }), j.P.extend({ addKeyboardShortcuts: () => ({}) }).configure({ types: ["heading", "paragraph"] }), I.a, H.$, ey, eB, eR, eE, A.ZT, y.V.configure({ includeChildren: !0, showOnlyCurrent: !1, placeholder: () => "" }), e_, S.F, eG, eQ, L.m.configure({ width: 2, class: "ProseMirror-dropcursor border-black" })] }, tK = (0, c.createContext)({ isAiLoading: !1, aiError: null, setIsAiLoading: () => { }, setAiError: () => { } }), tJ = () => { let [e, t] = (0, c.useState)(!1); return { isOpen: e, open: (0, c.useCallback)(() => { t(!0) }, []), close: (0, c.useCallback)(() => { t(!1) }, []), toggle: (0, c.useCallback)(() => { t(e => !e) }, []) } }, t$ = { type: "doc", content: [{ type: "heading", attrs: { textAlign: "left", level: 1 }, content: [{ type: "emoji", attrs: { name: "fire" } }, { type: "text", text: " Next.js + Tiptap Block Editor Template" }] }, { type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "Welcome to our React Block Editor Template built on top of " }, { type: "text", marks: [{ type: "link", attrs: { href: "https://tiptap.dev/", target: "_blank", class: null } }], text: "Tiptap" }, { type: "text", text: ", " }, { type: "text", marks: [{ type: "link", attrs: { href: "https://nextjs.org/", target: "_blank", class: null } }], text: "Next.js" }, { type: "text", text: " and " }, { type: "text", marks: [{ type: "link", attrs: { href: "https://tailwindcss.com/", target: "_blank", class: null } }], text: "Tailwind" }, { type: "text", text: ". This project can be a good starting point for your own implementation of a block editor." }] }, { type: "codeBlock", attrs: { language: null }, content: [{ type: "text", text: "import { useEditor, EditorContent } from '@tiptap/react'\n\nfunction App() {\n  const editor = useEditor()\n\n  return <EditorContent editor={editor} />\n}" }] }, { type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "This editor includes features like:" }] }, { type: "bulletList", content: [{ type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "A DragHandle including a DragHandle menu" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "A Slash menu that can be triggered via typing a " }, { type: "text", marks: [{ type: "code" }], text: "/" }, { type: "text", text: " into an empty paragraph or by using the " }, { type: "text", marks: [{ type: "bold" }], text: "+ Button" }, { type: "text", text: " next to the drag handle" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "A TextFormatting menu that allows you to change the " }, { type: "text", marks: [{ type: "textStyle", attrs: { fontSize: "18px", fontFamily: null, color: null } }], text: "font size" }, { type: "text", text: ", " }, { type: "text", marks: [{ type: "bold" }], text: "font weight" }, { type: "text", text: ", " }, { type: "text", marks: [{ type: "textStyle", attrs: { fontSize: null, fontFamily: "Georgia", color: null } }], text: "font family" }, { type: "text", text: ", " }, { type: "text", marks: [{ type: "textStyle", attrs: { fontSize: null, fontFamily: null, color: "#b91c1c" } }], text: "color" }, { type: "text", text: ", " }, { type: "text", marks: [{ type: "highlight", attrs: { color: "#7e7922" } }], text: "highlight" }, { type: "text", text: " and more" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "A Table of Contents that can be viewed via clicking on the button on the top left corner" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "Live collaboration including content synchronization and collaborative cursors" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "AI implementation with text and image generation and auto completion via the " }, { type: "text", marks: [{ type: "code" }], text: "TAB" }, { type: "text", text: " key." }] }] }] }, { type: "imageBlock", attrs: { src: "/placeholder-image.jpg", width: "100%", align: "center" } }, { type: "heading", attrs: { textAlign: "left", level: 2 }, content: [{ type: "text", text: "Get started" }] }, { type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "To access our block editor template, simply head over to your " }, { type: "text", marks: [{ type: "link", attrs: { href: "https://cloud.tiptap.dev/react-templates", target: "_blank", class: null } }], text: "Tiptap Account" }, { type: "text", text: " If you are not already a member, sign up for an account and complete the 2-minute React Template survey. Once finished, we will send you an invite to the private GitHub repository." }] }, { type: "heading", attrs: { textAlign: "left", level: 2 }, content: [{ type: "text", text: "Installed extensions" }] }, { type: "bulletList", content: [{ type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap-pro/extension-ai" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap-pro/extension-drag-handle" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap-pro/extension-drag-handle-react" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap-pro/extension-emoji" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap-pro/extension-file-handler" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap-pro/extension-mathematics" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap-pro/extension-node-range" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap-pro/extension-table-of-contents" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap-pro/extension-unique-id" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-bullet-list" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-character-count" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-code-block" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-code-block-lowlight" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-collaboration" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-collaboration-cursor" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-color" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-document" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-dropcursor" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-focus" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-font-family" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-heading" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-highlight" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-horizontal-rule" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-image" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-link" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-ordered-list" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-paragraph" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-placeholder" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-subscript" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-superscript" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-table" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-table-header" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-table-row" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-task-item" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-task-list" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-text-align" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-text-style" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-typography" }] }] }, { type: "listItem", content: [{ type: "paragraph", attrs: { class: null, textAlign: "left" }, content: [{ type: "text", text: "@tiptap/extension-underline" }] }] }] }, { type: "paragraph", attrs: { class: null, textAlign: "left" } }] }, tG = e => { var t; let { aiToken: a, ydoc: n, provider: l } = e, r = tJ(), [i, o] = (0, c.useState)(l ? s.X0.Connecting : s.X0.Disconnected), { setIsAiLoading: d, setAiError: p } = (0, c.useContext)(tK), m = (0, u.jE)({ immediatelyRender: !1, autofocus: !0, onCreate: e => { let { editor: t } = e; l ? l.on("synced", () => { t.isEmpty && t.commands.setContent(t$) }) : (t.commands.setContent(t$), t.commands.focus("start", { scrollIntoView: !0 })) }, extensions: [...t_({ provider: l }), l ? E.ZP.configure({ document: n }) : void 0, l ? T.Z.configure({ provider: l, user: { name: tp(et), color: tp(ea) } }) : void 0, tq.ZP.configure({ appId: "79drg0x6", token: a, baseUrl: "https://api-demo.tiptap.dev/v1/ai", autocompletion: !0, onLoading: () => { d(!0), p(null) }, onSuccess: () => { d(!1), p(null) }, onError: e => { d(!1), p(e.message) } })].filter(e => !!e), editorProps: { attributes: { autocomplete: "off", autocorrect: "off", autocapitalize: "off", class: "min-h-full" } } }, [n, l]), h = (0, c.useMemo)(() => { var e, t; return (null == m ? void 0 : null === (e = m.storage.collaborationCursor) || void 0 === e ? void 0 : e.users) ? null === (t = m.storage.collaborationCursor) || void 0 === t ? void 0 : t.users.map(e => { var t; let a = null === (t = e.name) || void 0 === t ? void 0 : t.split(" "), n = null == a ? void 0 : a[0], l = null == a ? void 0 : a[a.length - 1], r = "".concat((null == n ? void 0 : n[0]) || "?").concat((null == l ? void 0 : l[0]) || "?"); return { ...e, initials: r.length ? r : "?" } }) : [] }, [null == m ? void 0 : null === (t = m.storage.collaborationCursor) || void 0 === t ? void 0 : t.users]), x = (null == m ? void 0 : m.storage.characterCount) || { characters: () => 0, words: () => 0 }; return (0, c.useEffect)(() => { null == l || l.on("status", e => { o(e.status) }) }, [l]), window.editor = m, { editor: m, users: h, characterCount: x, collabState: i, leftSidebar: r } }; a(7208); let tY = (0, c.memo)(e => { let { editor: t, isOpen: a, onClose: n } = e, l = (0, c.useCallback)(() => { window.innerWidth < 1024 && n() }, [n]), r = tu("absolute top-0 left-0 bg-white lg:bg-white/30 lg:backdrop-blur-xl h-full lg:h-auto lg:relative z-[999] w-0 duration-300 transition-all", "dark:bg-black lg:dark:bg-black/30", !a && "border-r-transparent", a && "w-80 border-r border-r-neutral-200 dark:border-r-neutral-800"); return (0, i.jsx)("div", { className: r, children: (0, i.jsx)("div", { className: "w-full h-full overflow-hidden", children: (0, i.jsx)("div", { className: "w-full h-full p-6 overflow-auto", children: (0, i.jsx)(tr, { onItemClick: l, editor: t }) }) }) }) }); tY.displayName = "TableOfContentSidepanel"; let tX = (0, c.memo)(e => { let { onChange: t, value: a } = e, [n, l] = (0, c.useState)(a); (0, c.useEffect)(() => { l(a) }, [a]); let r = (0, c.useCallback)(e => { let a = parseInt(e.target.value); t(a), l(a) }, [t]); return (0, i.jsxs)("div", { className: "flex items-center gap-2", children: [(0, i.jsx)("input", { className: "h-2 bg-neutral-200 border-0 rounded appearance-none fill-neutral-300", type: "range", min: "25", max: "100", step: "25", onChange: r, value: n }), (0, i.jsxs)("span", { className: "text-xs font-semibold text-neutral-500 select-none", children: [a, "%"] })] }) }); tX.displayName = "ImageBlockWidth"; var tQ = e => { let { editor: t, appendTo: a } = e, n = (0, c.useRef)(null), l = (0, c.useRef)(null), r = (0, c.useCallback)(() => { let e = x(t, "node-imageBlock"); return (null == e ? void 0 : e.getBoundingClientRect()) || new DOMRect(-1e3, -1e3, 0, 0) }, [t]), s = (0, c.useCallback)(() => t.isActive("imageBlock"), [t]), o = (0, c.useCallback)(() => { t.chain().focus(void 0, { scrollIntoView: !1 }).setImageBlockAlign("left").run() }, [t]), d = (0, c.useCallback)(() => { t.chain().focus(void 0, { scrollIntoView: !1 }).setImageBlockAlign("center").run() }, [t]), p = (0, c.useCallback)(() => { t.chain().focus(void 0, { scrollIntoView: !1 }).setImageBlockAlign("right").run() }, [t]), m = (0, c.useCallback)(e => { t.chain().focus(void 0, { scrollIntoView: !1 }).setImageBlockWidth(e).run() }, [t]); return (0, i.jsx)(u.NM, { editor: t, pluginKey: "imageBlockMenu-".concat((0, W.Z)()), shouldShow: s, updateDelay: 0, tippyOptions: { offset: [0, 8], popperOptions: { modifiers: [{ name: "flip", enabled: !1 }] }, getReferenceClientRect: r, onCreate: e => { l.current = e }, appendTo: () => null == a ? void 0 : a.current, plugins: [eW.CA], sticky: "popper" }, children: (0, i.jsxs)(ep.Wrapper, { shouldShowContent: s(), ref: n, children: [(0, i.jsx)(ep.Button, { tooltip: "Align image left", active: t.isActive("imageBlock", { align: "left" }), onClick: o, children: (0, i.jsx)(th, { name: "AlignHorizontalDistributeStart" }) }), (0, i.jsx)(ep.Button, { tooltip: "Align image center", active: t.isActive("imageBlock", { align: "center" }), onClick: d, children: (0, i.jsx)(th, { name: "AlignHorizontalDistributeCenter" }) }), (0, i.jsx)(ep.Button, { tooltip: "Align image right", active: t.isActive("imageBlock", { align: "right" }), onClick: p, children: (0, i.jsx)(th, { name: "AlignHorizontalDistributeEnd" }) }), (0, i.jsx)(ep.Divider, {}), (0, i.jsx)(tX, { onChange: m, value: parseInt(t.getAttributes("imageBlock").width) })] }) }) }; let t0 = e => { let { editor: t, appendTo: a } = e, n = (0, c.useCallback)(() => { let e = x(t, "columns"); return (null == e ? void 0 : e.getBoundingClientRect()) || new DOMRect(-1e3, -1e3, 0, 0) }, [t]), l = (0, c.useCallback)(() => t.isActive("columns"), [t]), s = (0, c.useCallback)(() => { t.chain().focus().setLayout(r.SidebarLeft).run() }, [t]), o = (0, c.useCallback)(() => { t.chain().focus().setLayout(r.SidebarRight).run() }, [t]), d = (0, c.useCallback)(() => { t.chain().focus().setLayout(r.TwoColumn).run() }, [t]); return (0, i.jsx)(u.NM, { editor: t, pluginKey: "columnsMenu-".concat((0, W.Z)()), shouldShow: l, updateDelay: 0, tippyOptions: { offset: [0, 8], popperOptions: { modifiers: [{ name: "flip", enabled: !1 }] }, getReferenceClientRect: n, appendTo: () => null == a ? void 0 : a.current, plugins: [eW.CA], sticky: "popper" }, children: (0, i.jsxs)(ep.Wrapper, { children: [(0, i.jsx)(ep.Button, { tooltip: "Sidebar left", active: t.isActive("columns", { layout: r.SidebarLeft }), onClick: s, children: (0, i.jsx)(th, { name: "PanelLeft" }) }), (0, i.jsx)(ep.Button, { tooltip: "Two columns", active: t.isActive("columns", { layout: r.TwoColumn }), onClick: d, children: (0, i.jsx)(th, { name: "Columns" }) }), (0, i.jsx)(ep.Button, { tooltip: "Sidebar right", active: t.isActive("columns", { layout: r.SidebarRight }), onClick: o, children: (0, i.jsx)(th, { name: "PanelRight" }) })] }) }) }; tw.xz, tw.h_; let t1 = e => { let { label: t, close: a = !0, icon: n, iconComponent: l, disabled: r, onClick: s, isActive: o } = e, c = tu("flex items-center gap-2 p-1.5 text-sm font-medium text-neutral-500 text-left bg-transparent w-full rounded", !o && !r, "hover:bg-neutral-100 hover:text-neutral-800 dark:hover:bg-neutral-900 dark:hover:text-neutral-200", o && !r && "bg-neutral-100 text-neutral-800 dark:bg-neutral-900 dark:text-neutral-200", r && "text-neutral-400 cursor-not-allowed dark:text-neutral-600"), d = n ? tm[n] : null, u = a ? tw.x8 : "button"; return (0, i.jsxs)(u, { className: c, onClick: s, disabled: r, children: [d && (0, i.jsx)(d, { className: "w-4 h-4" }), l || null, t] }) }; (0, c.forwardRef)((e, t) => (0, i.jsx)("hr", { ...e, ref: t, className: "my-1 border-neutral-200 dark:border-neutral-800" })).displayName = "Divider"; let t2 = e => { let { editor: t, view: a, state: n, from: l } = e, r = a.domAtPos(l).node, i = a.nodeDOM(l) || r; if (!t.isActive(ey.name) || !i || eS(n.selection)) return !1; let s = i; for (; s && !["TD", "TH"].includes(s.tagName);)s = s.parentElement; return !!(s && s.querySelector && s.querySelector("a.grip-column.selected")) }, t5 = c.memo(e => { let { editor: t, appendTo: a } = e, n = (0, c.useCallback)(e => { let { view: a, state: n, from: l } = e; return !!n && t2({ editor: t, view: a, state: n, from: l || 0 }) }, [t]), l = (0, c.useCallback)(() => { t.chain().focus().addColumnBefore().run() }, [t]), r = (0, c.useCallback)(() => { t.chain().focus().addColumnAfter().run() }, [t]), s = (0, c.useCallback)(() => { t.chain().focus().deleteColumn().run() }, [t]); return (0, i.jsx)(u.NM, { editor: t, pluginKey: "tableColumnMenu", updateDelay: 0, tippyOptions: { appendTo: () => null == a ? void 0 : a.current, offset: [0, 15], popperOptions: { modifiers: [{ name: "flip", enabled: !1 }] } }, shouldShow: n, children: (0, i.jsxs)(ep.Wrapper, { isVertical: !0, children: [(0, i.jsx)(t1, { iconComponent: (0, i.jsx)(th, { name: "ArrowLeftToLine" }), close: !1, label: "Add column before", onClick: l }), (0, i.jsx)(t1, { iconComponent: (0, i.jsx)(th, { name: "ArrowRightToLine" }), close: !1, label: "Add column after", onClick: r }), (0, i.jsx)(t1, { icon: "Trash", close: !1, label: "Delete column", onClick: s })] }) }) }); t5.displayName = "TableColumnMenu"; let t4 = e => { let { editor: t, view: a, state: n, from: l } = e, r = a.domAtPos(l).node, i = a.nodeDOM(l) || r; if (!t.isActive(ey.name) || !i || eS(n.selection)) return !1; let s = i; for (; s && !["TD", "TH"].includes(s.tagName);)s = s.parentElement; return !!(s && s.querySelector && s.querySelector("a.grip-row.selected")) }, t8 = c.memo(e => { let { editor: t, appendTo: a } = e, n = (0, c.useCallback)(e => { let { view: a, state: n, from: l } = e; return !!n && !!l && t4({ editor: t, view: a, state: n, from: l }) }, [t]), l = (0, c.useCallback)(() => { t.chain().focus().addRowBefore().run() }, [t]), r = (0, c.useCallback)(() => { t.chain().focus().addRowAfter().run() }, [t]), s = (0, c.useCallback)(() => { t.chain().focus().deleteRow().run() }, [t]); return (0, i.jsx)(u.NM, { editor: t, pluginKey: "tableRowMenu", updateDelay: 0, tippyOptions: { appendTo: () => null == a ? void 0 : a.current, placement: "left", offset: [0, 15], popperOptions: { modifiers: [{ name: "flip", enabled: !1 }] } }, shouldShow: n, children: (0, i.jsxs)(ep.Wrapper, { isVertical: !0, children: [(0, i.jsx)(t1, { iconComponent: (0, i.jsx)(th, { name: "ArrowUpToLine" }), close: !1, label: "Add row before", onClick: l }), (0, i.jsx)(t1, { iconComponent: (0, i.jsx)(th, { name: "ArrowDownToLine" }), close: !1, label: "Add row after", onClick: r }), (0, i.jsx)(t1, { icon: "Trash", close: !1, label: "Delete row", onClick: s })] }) }) }); t8.displayName = "TableRowMenu"; let t9 = () => { let [e, t] = (0, c.useState)(!1), [a, n] = (0, c.useState)(null); return { isAiLoading: e, aiError: a, setIsAiLoading: t, setAiError: n } }, t3 = (0, c.memo)(e => { let { characters: t, collabState: a, users: n, words: l } = e; return (0, i.jsxs)("div", { className: "flex items-center", children: [(0, i.jsxs)("div", { className: "flex flex-col justify-center pr-4 mr-4 text-right border-r border-neutral-200 dark:border-neutral-800", children: [(0, i.jsxs)("div", { className: "text-xs font-semibold text-neutral-500 dark:text-neutral-400", children: [l, " ", 1 === l ? "word" : "words"] }), (0, i.jsxs)("div", { className: "text-xs font-semibold text-neutral-500 dark:text-neutral-400", children: [t, " ", 1 === t ? "character" : "characters"] })] }), (0, i.jsxs)("div", { className: "flex items-center gap-2 mr-2", children: [(0, i.jsx)("div", { className: tu("w-2 h-2 rounded-full", { "bg-yellow-500 dark:bg-yellow-400": "connecting" === a, "bg-green-500 dark:bg-green-400": "connected" === a, "bg-red-500 dark:bg-red-400": "disconnected" === a }) }), (0, i.jsx)("span", { className: "max-w-[4rem] text-xs text-neutral-500 dark:text-neutral-400 font-semibold", children: h(a) })] }), "connected" === a && (0, i.jsx)("div", { className: "flex flex-row items-center", children: (0, i.jsxs)("div", { className: "relative flex flex-row items-center ml-3", children: [n.map(e => (0, i.jsx)("div", { className: "-ml-3", children: (0, i.jsx)(eo, { title: e.name, children: (0, i.jsx)("img", { className: "w-8 h-8 border border-white rounded-full dark:border-black", src: "https://api.dicebear.com/7.x/notionists-neutral/svg?seed=".concat(e.name, "&backgroundColor=").concat(e.color.replace("#", "")), alt: "avatar" }) }) }, e.clientId)), n.length > 3 && (0, i.jsx)("div", { className: "-ml-3", children: (0, i.jsxs)("div", { className: "flex items-center justify-center w-8 h-8 font-bold text-xs leading-none border border-white dark:border-black bg-[#FFA2A2] rounded-full", children: ["+", n.length - 3] }) })] }) })] }) }); t3.displayName = "EditorInfo"; let t7 = e => { let { characters: t, collabState: a, users: n, words: l, isSidebarOpen: r, toggleSidebar: s } = e; return (0, i.jsxs)("div", { className: "flex flex-row items-center justify-between flex-none py-2 pl-6 pr-3 text-black bg-white border-b border-neutral-200 dark:bg-black dark:text-white dark:border-neutral-800", children: [(0, i.jsx)("div", { className: "flex flex-row gap-x-1.5 items-center", children: (0, i.jsx)("div", { className: "flex items-center gap-x-1.5", children: (0, i.jsx)(ep.Button, { tooltip: r ? "Close sidebar" : "Open sidebar", onClick: s, active: r, className: r ? "bg-transparent" : "", children: (0, i.jsx)(th, { name: r ? "PanelLeftClose" : "PanelLeft" }) }) }) }), (0, i.jsx)(t3, { characters: t, words: l, collabState: a, users: n })] }) }, t6 = e => { let { aiToken: t, ydoc: a, provider: n } = e, l = t9(), r = (0, c.useRef)(null), { editor: s, users: o, characterCount: d, collabState: p, leftSidebar: m } = tG({ aiToken: t, ydoc: a, provider: n }), h = o.slice(0, 3), x = (0, c.useMemo)(() => ({ isAiLoading: l.isAiLoading, aiError: l.aiError, setIsAiLoading: l.setIsAiLoading, setAiError: l.setAiError }), [l]); if (!s) return null; let g = (0, Z.createPortal)((0, i.jsx)(K, { label: "AI is now doing its job." }), document.body); return (0, i.jsxs)(tK.Provider, { value: x, children: [(0, i.jsxs)("div", { className: "flex h-full", ref: r, children: [(0, i.jsx)(tY, { isOpen: m.isOpen, onClose: m.close, editor: s }), (0, i.jsxs)("div", { className: "relative flex flex-col flex-1 h-full overflow-hidden", children: [(0, i.jsx)(t7, { characters: d.characters(), collabState: p, users: h, words: d.words(), isSidebarOpen: m.isOpen, toggleSidebar: m.toggle }), (0, i.jsx)(u.kg, { editor: s, className: "flex-1 overflow-y-auto" }), (0, i.jsx)(tW, { editor: s }), (0, i.jsx)(tk, { editor: s, appendTo: r }), (0, i.jsx)(tO, { editor: s }), (0, i.jsx)(t0, { editor: s, appendTo: r }), (0, i.jsx)(t8, { editor: s, appendTo: r }), (0, i.jsx)(t5, { editor: s, appendTo: r }), (0, i.jsx)(tQ, { editor: s, appendTo: r })] })] }), l.isAiLoading && g] }) }, ae = () => { let [e, t] = (0, c.useState)(window.matchMedia("(prefers-color-scheme: dark)").matches); return (0, c.useEffect)(() => { let e = window.matchMedia("(prefers-color-scheme: dark)"), a = () => t(e.matches); return e.addEventListener("change", a), () => e.removeEventListener("change", a) }, []), (0, c.useEffect)(() => { document.documentElement.classList.toggle("dark", e) }, [e]), { isDarkMode: e, toggleDarkMode: (0, c.useCallback)(() => t(e => !e), []), lightMode: (0, c.useCallback)(() => t(!1), []), darkMode: (0, c.useCallback)(() => t(!0), []) } }; function at(e) { let { params: t } = e, { isDarkMode: a, darkMode: n, lightMode: l } = ae(), [r, u] = (0, c.useState)(null), [p, m] = (0, c.useState)(null), [h, x] = (0, c.useState)(null), g = 1 !== parseInt((0, o.useSearchParams)().get("noCollab")), { room: f } = t; (0, c.useEffect)(() => { (async () => { let { token: e } = await (await fetch("/api/collaboration", { method: "POST", headers: { "Content-Type": "application/json" } })).json(); m(e) })() }, []), (0, c.useEffect)(() => { (async () => { let { token: e } = await (await fetch("/api/ai", { method: "POST", headers: { "Content-Type": "application/json" } })).json(); x(e) })() }, []); let b = (0, c.useMemo)(() => new d.QW, []); if ((0, c.useLayoutEffect)(() => { g && p && u(new s.jg({ name: "".concat("demos-").concat(f), appId: "vyko4m51", token: p, document: b })) }, [u, p, b, f, g]), g && (!p || !r) || !h) return; let v = (0, Z.createPortal)((0, i.jsxs)($, { className: "flex items-center gap-1 fixed bottom-6 right-6 z-[99999] p-1", children: [(0, i.jsx)(ep.Button, { onClick: l, active: !a, children: (0, i.jsx)(th, { name: "Sun" }) }), (0, i.jsx)(ep.Button, { onClick: n, active: a, children: (0, i.jsx)(th, { name: "Moon" }) })] }), document.body); return (0, i.jsxs)(i.Fragment, { children: [v, (0, i.jsx)(t6, { aiToken: h, hasCollab: g, ydoc: b, provider: r })] }) } }, 7208: function () { } }, function (e) { e.O(0, [900, 572, 902, 178, 955, 971, 69, 744], function () { return e(e.s = 6987) }), _N_E = e.O() }]);